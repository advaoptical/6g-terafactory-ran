diff --git a/.vscode/launch.json b/.vscode/launch.json
index 8be6915763..a8dbd354de 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -8,22 +8,60 @@
             "name": "(gdb) Launch",
             "type": "cppdbg",
             "request": "launch",
-            "program": "${workspaceFolder}/cmake_targets/ran_build/build/lte-softmodem",
+            "program": "${workspaceFolder}/cmake_targets/ran_build/build/nr-softmodem",
             "args": [
-                "-O", "../ci-scripts/conf_files/rcc.band7.tm1.nfapi.conf",
-                "--noS1"
+                "-O", "${workspaceFolder}/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fh.band78.fr1.273PRB.conf",
+                "--sa",
+                "--reorder-thread-disable"
             ],
             "stopAtEntry": false,
-            "cwd": "${workspaceFolder}/cmake_targets",
+            "cwd": "${workspaceFolder}/cmake_targets/ran_build/build",
+            // "cwd": "${fileDirname}",
             "environment": [],
             "externalConsole": false,
             "MIMode": "gdb",
-            "miDebuggerPath": "${workspaceFolder}/cmake_targets/sudo-gdb",
+            "miDebuggerPath": "${workspaceFolder}/sudo-gdb",
             "setupCommands": [
                 {
                     "description": "Enable pretty-printing for gdb",
                     "text": "-enable-pretty-printing",
                     "ignoreFailures": true
+                },
+                {
+                    "description": "Set Disassembly Flavor to Intel",
+                    "text": "-gdb-set disassembly-flavor intel",
+                    "ignoreFailures": true
+                }
+            ]
+        },
+        {
+            "name": "(gdb) nFAPI VNF",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${workspaceFolder}/cmake_targets/ran_build/build/nr-softmodem",
+            "args": [
+                "-O", "${workspaceFolder}/targets/PROJECTS/GENERIC-LTE-EPC/CONF/rcc.band78.tm1.106PRB.nfapi.conf",
+                // "--sa",
+                "--nfapi","VNF",
+                "--phy-test"
+            ],
+            "stopAtEntry": false,
+            "cwd": "${workspaceFolder}/cmake_targets/ran_build/build",
+            // "cwd": "${fileDirname}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "miDebuggerPath": "${workspaceFolder}/sudo-gdb",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                },
+                {
+                    "description": "Set Disassembly Flavor to Intel",
+                    "text": "-gdb-set disassembly-flavor intel",
+                    "ignoreFailures": true
                 }
             ]
         }
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0fd625e10d..71b15470b1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -146,6 +146,7 @@ endif()
 #########################################################
 set (NFAPI_DIR       ${OPENAIR_DIR}/nfapi/open-nFAPI)
 set (NFAPI_USER_DIR  ${OPENAIR_DIR}/nfapi/oai_integration)
+set (FAPI_ORAN_DIR   ${OPENAIR_DIR}/nfapi/oran-fapi)
 set (OPENAIR1_DIR    ${OPENAIR_DIR}/openair1)
 set (OPENAIR2_DIR    ${OPENAIR_DIR}/openair2)
 set (OPENAIR3_DIR    ${OPENAIR_DIR}/openair3)
@@ -161,9 +162,10 @@ else()
   set (XRAN_LIB_DIR /usr/local/xran)
 endif()
 
-set (XRAN_DIR         $ENV{XRAN_LIB_DIR}/../src)
-set (XRAN_COMMON_DIR  $ENV{XRAN_LIB_DIR}/../../test/common)
-set (XRAN_LIB_API_DIR $ENV{XRAN_LIB_DIR}/../api)
+set (XRAN_DIR         $ENV{XRAN_LIB_DIR}/lib/src)
+set (XRAN_COMMON_DIR  $ENV{XRAN_LIB_DIR}/test/common)
+set (XRAN_LIB_API_DIR $ENV{XRAN_LIB_DIR}/lib/api)
+# set (GTEST_API_DIR $ENV{GTEST_ROOT}/include)
 
 Message("XRAN_LIB_DIR: ${XRAN_LIB_DIR}, DPDK_DIR: ${DPDK_DIR}")
 project (OpenAirInterface)
@@ -629,14 +631,33 @@ target_include_directories(oran_fhlib_5g PRIVATE ${XRAN_DIR})
 target_include_directories(oran_fhlib_5g PRIVATE ${DPDK_DIR})
 target_include_directories(oran_fhlib_5g PRIVATE ${INTEL_LIB})
 target_include_directories(oran_fhlib_5g PRIVATE ${XRAN_COMMON_DIR})
+# target_include_directories(oran_fhlib_5g PRIVATE ${GTEST_API_DIR})
 target_include_directories(oran_fhlib_5g PRIVATE ${XRAN_LIB_API_DIR})
 
 set_target_properties(oran_fhlib_5g PROPERTIES COMPILE_FLAGS "-fvisibility=hidden -march=native -I$ENV{RTE_SDK}/$ENV{RTE_TARGET}/include")
 
-SET(DPDK_LIBS "-Wl,-rpath,$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -Wl,--whole-archive -L$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -ldpdk -Wl,--no-whole-archive")
-TARGET_LINK_LIBRARIES(oran_fhlib_5g PRIVATE ${DPDK_LIBS})
-TARGET_LINK_LIBRARIES(oran_fhlib_5g PRIVATE -L${XRAN_LIB_DIR} -lxran)
-TARGET_LINK_LIBRARIES(oran_fhlib_5g PRIVATE pthread dl rt m numa)
+#AAA
+execute_process(COMMAND  pkg-config --libs libdpdk OUTPUT_VARIABLE DPDK_LIBS)
+string(STRIP ${DPDK_LIBS} DPDK_LIBS)
+message(STATUS "AAA MY_VAR=${DPDK_LIBS}")
+# # pkg-config --libs libdpdk
+# # -rpath is for: to specify the libraries to be searched at run time
+# SET(DPDK_LIBS "-Wl,-rpath,$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -Wl,--whole-archive  -L$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -lrte_node -lrte_graph -lrte_bpf\
+#  -lrte_flow_classify -lrte_pipeline -lrte_table -lrte_port -lrte_fib -lrte_ipsec\
+#  -lrte_vhost -lrte_stack -lrte_security -lrte_sched -lrte_reorder -lrte_rib\
+#  -lrte_regexdev -lrte_rawdev -lrte_pdump -lrte_power -lrte_member -lrte_lpm\
+#  -lrte_latencystats -lrte_kni -lrte_jobstats -lrte_ip_frag -lrte_gso -lrte_gro\
+#  -lrte_eventdev -lrte_efd -lrte_distributor -lrte_cryptodev -lrte_compressdev\
+#  -lrte_cfgfile -lrte_bitratestats -lrte_bbdev -lrte_acl -lrte_timer\
+#  -lrte_hash -lrte_metrics -lrte_cmdline -lrte_pci -lrte_ethdev\
+#  -lrte_meter -lrte_net -lrte_mbuf -lrte_mempool -lrte_rcu -lrte_ring\
+#   -lrte_eal -lrte_telemetry -lrte_kvargs -lrte_bbdev\
+#    -Wl,--no-whole-archive")
+
+# SET(DPDK_LIBS "-Wl,-rpath,$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -Wl,--whole-archive -L$ENV{RTE_SDK}/$ENV{RTE_TARGET}/lib -ldpdk -Wl,--no-whole-archive")
+target_link_libraries(oran_fhlib_5g PRIVATE -L${XRAN_LIB_DIR} -lxran)
+target_link_libraries(oran_fhlib_5g PRIVATE ${DPDK_LIBS})
+target_link_libraries(oran_fhlib_5g PRIVATE pthread dl rt m numa)
 target_link_libraries(oran_fhlib_5g PRIVATE asn1_nr_rrc asn1_lte_rrc)
 
 ##########################################################
@@ -644,7 +665,8 @@ target_link_libraries(oran_fhlib_5g PRIVATE asn1_nr_rrc asn1_lte_rrc)
 # LDPC offload library
 ##########################################################
 
-add_boolean_option(ENABLE_LDPC_T1 OFF "Build support for LDPC Offload to T1 library" OFF)
+add_boolean_option(ENABLE_LDPC_T1 FALSE "Build support for LDPC Offload to T1 library" OFF)
+set(ENABLE_LDPC_T1 FALSE)
 if (ENABLE_LDPC_T1)
   pkg_check_modules(LIBDPDK_T1 REQUIRED libdpdk=20.05.0)
   find_library(T1 NAMES rte_pmd_hpac_sdfec_pmd REQUIRED)
@@ -758,6 +780,7 @@ else()
   include_directories("${OPENAIR2_DIR}/UTIL/LOG")
 endif()
 include_directories("${NFAPI_DIR}/nfapi/public_inc")
+include_directories("${FAPI_ORAN_DIR}")
 include_directories("${NFAPI_DIR}/common/public_inc")
 include_directories("${NFAPI_DIR}/pnf/public_inc")
 include_directories("${NFAPI_DIR}/nfapi/inc")
@@ -958,6 +981,12 @@ target_link_libraries(NFAPI_VNF_LIB PRIVATE asn1_nr_rrc asn1_lte_rrc)
 include_directories(${NFAPI_DIR}/vnf/public_inc)
 include_directories(${NFAPI_DIR}/vnf/inc)
 
+set(FAPI_ORAN_SRC
+  ${FAPI_ORAN_DIR}/mac_main.c
+  ${FAPI_ORAN_DIR}/mac_wls.c
+)
+add_library(FAPI_ORAN_LIB ${FAPI_ORAN_SRC})
+
 # nFAPI user defined code
 #############################
 set(NFAPI_USER_SRC
@@ -1053,7 +1082,8 @@ add_dependencies(ldpc_cl nrLDPC_decoder_kernels_CL)
 # Base CUDA setting
 ##############################################
 
-add_boolean_option(ENABLE_LDPC_CUDA OFF "Build support for CUDA" OFF)
+add_boolean_option(ENABLE_LDPC_CUDA False "Build support for CUDA" OFF)
+set(ENABLE_LDPC_CUDA FALSE)
 if (ENABLE_LDPC_CUDA)
   find_package(CUDA REQUIRED)
   SET(CUDA_NVCC_FLAG "${CUDA_NVCC_FLAGS};-arch=sm_60;")
diff --git a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
index 8d16fc7898..c775ac3b9e 100644
--- a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
+++ b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
@@ -41,6 +41,7 @@
 #include "OCG.h"
 #include "RRC/NR/nr_rrc_extern.h"
 #include "common/utils/nr/nr_common.h"
+#include "PHY/defs_nr_common.h"
 
 
 #include "pdcp.h"
diff --git a/radio/ETHERNET/oran/5g/oran.cpp b/radio/ETHERNET/oran/5g/oran.cpp
index 26a38ff4da..441e855ad8 100644
--- a/radio/ETHERNET/oran/5g/oran.cpp
+++ b/radio/ETHERNET/oran/5g/oran.cpp
@@ -97,22 +97,24 @@ void xran_fh_rx_callback(void *pCallbackTag, xran_status_t status)
   uint32_t frame;
   uint32_t subframe;
   uint32_t slot;
-  tti = xran_get_slot_idx(&frame, &subframe, &slot, &second);
-
+  tti = xran_get_slot_idx(0, &frame, &subframe, &slot, &second);
   rx_tti = callback_tag->slotiId;
   rx_sym = callback_tag->symbol;
-  if (rx_sym == 7) {
+  // printf("AAA rx_callback rx_tti:%d, rx_sym:%d, tti:%d\n", rx_tti, rx_sym, tti);
+  if (rx_sym == XRAN_FULL_CB_SYM) {
     if (first_call_set) {
       if (!first_rx_set) {
         printf("first_rx is set\n");
       }
       first_rx_set = 1;
     }
+    // AAA naive. This is to be processed in ru_thread
     rx_cb_tti = tti;
     rx_cb_frame = frame;
     rx_cb_subframe = subframe;
     rx_cb_slot = slot;
   }
+  rte_pause();
 }
 void xran_fh_srs_callback(void *pCallbackTag, xran_status_t status)
 {
@@ -122,12 +124,17 @@ void xran_fh_rx_prach_callback(void *pCallbackTag, xran_status_t status)
 {
   rte_pause();
 }
+void xran_fh_bfw_callback(void *pCallbackTag, xran_status_t status)
+{
+  rte_pause();
+}
 
 int physide_dl_tti_call_back(void *param)
 {
   if (!first_call_set)
     printf("first_call set from phy cb first_call_set=%p\n", &first_call_set);
   first_call_set = 1;
+  rte_pause();
   return 0;
 }
 
@@ -191,7 +198,11 @@ int setup_oran(void *xranlib_)
 int open_oran_callback(void *xranlib_)
 {
   xranLibWraper *xranlib = ((xranLibWraper *)xranlib_);
-  xranlib->Open(nullptr, nullptr, (void *)xran_fh_rx_callback, (void *)xran_fh_rx_prach_callback, (void *)xran_fh_srs_callback);
+  xranlib->Open(0, nullptr, nullptr, 
+      (void *)xran_fh_rx_callback, 
+      (void *)xran_fh_bfw_callback, 
+      (void *)xran_fh_rx_prach_callback, 
+      (void *)xran_fh_srs_callback);
 
   return (0);
 }
@@ -211,7 +222,7 @@ int initialize_oran(void *xranlib_)
 {
   xranLibWraper *xranlib = ((xranLibWraper *)xranlib_);
 
-  xranlib->Init();
+  xranlib->Init(0);
 
   return (0);
 }
@@ -276,7 +287,7 @@ int load_iq_from_file(void *xranlib_)
   int32_t number_slots = 40; // According to wrapper.hpp  uint32_t m_nSlots = 10; but for the file 5MHz is set to 40
   uint32_t numerology = xranlib->get_numerology(); // According to the conf file is mu number
   uint32_t bandwidth = 5; // According to the wrapper.hpp since we are reading the 5MHz files
-  uint32_t sub6 = xranlib->get_sub6();
+  bool sub6 = true;
   iq_playback_buffer_size_dl = (number_slots * N_SYM_PER_SLOT * N_SC_PER_PRB * xranlib->get_num_rbs(numerology, bandwidth, sub6) * 4L);
   const char *string_msg = "DL IFFT IN IQ Samples in binary format";
 
@@ -357,7 +368,7 @@ int xran_fh_tx_send_buffer(void *xranlib_)
             for (idxElm = 0; idxElm < pRbMap->nPrbElm; idxElm++) {
               struct xran_section_desc *p_sec_desc = NULL;
               p_prbMapElm = &pRbMap->prbMap[idxElm];
-              p_sec_desc = p_prbMapElm->p_sec_desc[sym_id];
+              p_sec_desc = p_prbMapElm->sec_desc[sym_id];
 
               if (p_sec_desc == NULL) {
                 printf("p_sec_desc == NULL\n");
@@ -414,23 +425,28 @@ int read_prach_data(ru_info_t *ru, int frame, int slot)
   struct rte_mbuf *mb;
 
   /* calculate tti and subframe_id from frame, slot num */
-  int tti = 20 * (frame) + (slot);
-  uint32_t subframe = XranGetSubFrameNum(tti, 2, 10);
-  uint32_t is_prach_slot = xran_is_prach_slot(subframe, (slot % 2));
+  // AAA hardcoded for mu1,30
+  unsigned tti = 20 * (frame) + (slot);
+  uint32_t subframe = XranGetSubFrameNum(tti, 2, 10); 
+  uint32_t is_prach_slot = xran_is_prach_slot(0, subframe, (slot % 2));
+  unsigned prach_idx = tti % 20; // AAA ? 40;
   int sym_idx = 0;
 
+  // AAA
+  printf("TTI:%d, frame:%d,slot:%d, SF:%d, is_prach:%d\n", tti, frame, slot, subframe, is_prach_slot);
+
   struct xran_prach_cp_config *pPrachCPConfig = &(p_xran_dev_ctx_2->PrachCPConfig);
 
   /* If it is PRACH slot, copy prach IQ from XRAN PRACH buffer to OAI PRACH buffer */
   if (is_prach_slot) {
     for (sym_idx = 0; sym_idx < pPrachCPConfig->numSymbol; sym_idx++) {
       for (int aa = 0; aa < ru->nb_rx; aa++) {
-        mb = (struct rte_mbuf *)p_xran_dev_ctx_2->sFHPrachRxBbuIoBufCtrl[tti % 40][0][aa].sBufferList.pBuffers[sym_idx].pCtrl;
+        mb = (struct rte_mbuf *)p_xran_dev_ctx_2->sFHPrachRxBbuIoBufCtrl[prach_idx][0][aa].sBufferList.pBuffers[sym_idx].pCtrl;
         if (mb) {
           uint16_t *dst, *src;
           int idx = 0;
           dst = (uint16_t *)((uint8_t *)ru->prach_buf[aa] + (sym_idx * 576));
-          src = (uint16_t *)((uint8_t *)p_xran_dev_ctx_2->sFHPrachRxBbuIoBufCtrl[tti % 40][0][aa].sBufferList.pBuffers[sym_idx].pData);
+          src = (uint16_t *)((uint8_t *)p_xran_dev_ctx_2->sFHPrachRxBbuIoBufCtrl[prach_idx][0][aa].sBufferList.pBuffers[sym_idx].pData);
 
           /* convert Network order to host order */
           for (idx = 0; idx < 576 / 2; idx++) {
@@ -453,7 +469,7 @@ int xran_fh_rx_read_slot(void *xranlib_, ru_info_t *ru, int *frame, int *slot, i
 
   void *ptr = NULL;
   int32_t *pos = NULL;
-  int idx = 0;
+  uint16_t idx = 0;
   static int print_tmp = 1;
   static int print_tmp_1 = 1;
 
@@ -526,7 +542,7 @@ int xran_fh_rx_read_slot(void *xranlib_, ru_info_t *ru, int *frame, int *slot, i
           for (idxElm = 0; idxElm < pRbMap->nPrbElm; idxElm++) {
             struct xran_section_desc *p_sec_desc = NULL;
             p_prbMapElm = &pRbMap->prbMap[idxElm];
-            p_sec_desc = p_prbMapElm->p_sec_desc[sym_id];
+            p_sec_desc = p_prbMapElm->sec_desc[sym_id];
 
             if (pRbMap->nPrbElm == 1 && idxElm == 0) {
               src = pData;
@@ -616,7 +632,7 @@ int xran_fh_tx_send_slot(void *xranlib_, ru_info_t *ru, int frame, int slot, uin
 
   void *ptr = NULL;
   int32_t *pos = NULL;
-  int idx = 0;
+  uint16_t idx = 0;
 
   p_xran_dev_ctx_2 = xran_dev_get_ctx();
 #if 0
@@ -666,7 +682,7 @@ int xran_fh_tx_send_slot(void *xranlib_, ru_info_t *ru, int frame, int slot, uin
           for (idxElm = 0; idxElm < pRbMap->nPrbElm; idxElm++) {
             struct xran_section_desc *p_sec_desc = NULL;
             p_prbMapElm = &pRbMap->prbMap[idxElm];
-            p_sec_desc = p_prbMapElm->p_sec_desc[sym_id];
+            p_sec_desc = p_prbMapElm->sec_desc[sym_id];
 
             payload_len = p_prbMapElm->nRBSize * N_SC_PER_PRB * 4L;
             dst = xran_add_hdr_offset(dst, p_prbMapElm->compMethod);
@@ -764,9 +780,10 @@ extern "C" {
 int compute_xran_statistics(void *xranlib_)
 {
   xranLibWraper *xranlib = ((xranLibWraper *)xranlib_);
+  uint32_t core_used;
 
   if (xran_get_common_counters(xranlib->get_xranhandle(), &x_counters) == XRAN_STATUS_SUCCESS) {
-    xran_get_time_stats(&nTotalTime, &nUsedTime, &nCoreUsed, 1);
+    xran_get_time_stats(&nTotalTime, &nUsedTime, &nCoreUsed, &core_used, 1);
     nUsedPercent = ((float)nUsedTime * 100.0) / (float)nTotalTime;
 
     printf("[rx %7ld pps %7ld kbps %7ld][tx %7ld pps %7ld kbps %7ld] [on_time %ld early %ld late %ld corrupt %ld pkt_dupl %ld Total %ld] IO Util: %5.2f %%\n",
diff --git a/radio/ETHERNET/oran/5g/oran_isolate.c b/radio/ETHERNET/oran/5g/oran_isolate.c
index 73bad8fe41..92a7615eae 100644
--- a/radio/ETHERNET/oran/5g/oran_isolate.c
+++ b/radio/ETHERNET/oran/5g/oran_isolate.c
@@ -68,7 +68,7 @@ int trx_oran_stop(openair0_device *device)
   return (0);
 }
 
-int trx_oran_set_freq(openair0_device *device, openair0_config_t *openair0_cfg, int exmimo_dump_config)
+int trx_oran_set_freq(openair0_device *device, openair0_config_t *openair0_cfg)
 {
   printf("ORAN: %s\n", __FUNCTION__);
   return (0);
@@ -195,7 +195,7 @@ void oran_fh_if4p5_south_in(RU_t *ru, int *frame, int *slot)
   ru_info_t ru_info;
   ru_info.nb_rx = ru->nb_rx;
   ru_info.rxdataF = ru->common.rxdataF;
-  ru_info.prach_buf = (int *)ru->prach_rxsigF[0]; // index: [prach_oca][ant_id]
+  ru_info.prach_buf = (int **)ru->prach_rxsigF[0]; // index: [prach_oca][ant_id]
 
   RU_proc_t *proc = &ru->proc;
   extern uint16_t sl_ahead;
@@ -205,6 +205,7 @@ void oran_fh_if4p5_south_in(RU_t *ru, int *frame, int *slot)
 
   if (ret != 0) {
     printf("ORAN: ORAN_fh_if4p5_south_in ERROR in RX function \n");
+    return;
   }
 
   proc->tti_rx = sl;
@@ -327,8 +328,9 @@ __attribute__((__visibility__("default"))) int transport_init(openair0_device *d
   printf("Init Oran. Done\n");
 
   // Open ORAN
-  open_oran(s->oran_priv);
-  printf("xran_open. Done\n");
+  // AAA already opened
+  // open_oran(s->oran_priv);
+  // printf("xran_open. Done\n");
 
   return 0;
 }
diff --git a/radio/ETHERNET/oran/5g/xran_lib_wrap.cpp b/radio/ETHERNET/oran/5g/xran_lib_wrap.cpp
index 78e8871173..f35e227293 100644
--- a/radio/ETHERNET/oran/5g/xran_lib_wrap.cpp
+++ b/radio/ETHERNET/oran/5g/xran_lib_wrap.cpp
@@ -35,7 +35,7 @@ json read_json_from_file(const std::string &filename)
 
   return result;
 }
-
+#if 0
 uint16_t xranLibWraper::get_eaxcid_mask(int numbit, int shift)
 {
   uint16_t result = 0;
@@ -47,1076 +47,6 @@ uint16_t xranLibWraper::get_eaxcid_mask(int numbit, int shift)
   return (result << shift);
 }
 
-int xranLibWraper::init_memory()
-{
-  xran_status_t status;
-  int32_t i, j, k;
-  uint32_t z;
-  SWXRANInterfaceTypeEnum eInterfaceType;
-  void *ptr;
-  void *mb;
-  uint32_t *u32dptr;
-
-  uint32_t xran_max_antenna_nr = RTE_MAX(get_num_eaxc(), get_num_eaxc_ul());
-  uint32_t xran_max_ant_array_elm_nr = RTE_MAX(get_num_antelmtrx(), xran_max_antenna_nr);
-
-  std::cout << "XRAN front haul xran_mm_init" << std::endl;
-  status = xran_mm_init(m_xranhandle, (uint64_t)SW_FPGA_FH_TOTAL_BUFFER_LEN, SW_FPGA_SEGMENT_BUFFER_LEN);
-  if (status != XRAN_STATUS_SUCCESS) {
-    std::cout << "Failed at XRAN front haul xran_mm_init" << std::endl;
-    return (-1);
-  }
-#if 0
-	// Define the sizes according to the specified parameters in the conf file not up to the maximim boudary
-        /* initialize maximum instances to have flexibility for the tests */
-        int nInstanceNum = XRAN_MAX_SECTOR_NR;
-        /* initialize maximum supported CC to have flexibility on the test */
-        int32_t nSectorNum = 6; //XRAN_MAX_SECTOR_NR;
-#endif
-  int32_t nSectorNum = get_num_cc();
-  int nInstanceNum = get_num_cc();
-
-  for (k = 0; k < XRAN_PORTS_NUM; k++) {
-    status = xran_sector_get_instances(m_xranhandle, nInstanceNum, &m_nInstanceHandle[k][0]);
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << "get sector instance failed " << k << " for XRAN nInstanceNum " << nInstanceNum << std::endl;
-      return (-1);
-    }
-    for (i = 0; i < nInstanceNum; i++)
-      std::cout << __func__ << " [" << k << "]: CC " << i << " handle " << m_nInstanceHandle[0][i] << std::endl;
-  }
-  std::cout << "Sucess xran_mm_init" << std::endl;
-
-  /* Init Memory */
-  printf("wrapper.hpp: Init memory *** XRANFTHTX_OUT ***\n");
-  for (i = 0; i < nSectorNum; i++) {
-    eInterfaceType = XRANFTHTX_OUT;
-    printf("Call xran_bm_init %d\n", i);
-    status =
-        xran_bm_init(m_nInstanceHandle[0][i], &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT, m_nSW_ToFpga_FTH_TxBufferLen);
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
-        m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFrontHaulTxBuffers[j][i][z][0];
-
-        for (k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
-          m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes = m_nSW_ToFpga_FTH_TxBufferLen; // 14 symbols 3200bytes/symbol
-          m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements = 1;
-          m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes = 0;
-          status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-          if (status != XRAN_STATUS_SUCCESS) {
-            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
-            return (-1);
-          }
-          m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
-          m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
-
-          if (ptr) {
-            u32dptr = (uint32_t *)(ptr);
-            memset(u32dptr, 0x0, m_nSW_ToFpga_FTH_TxBufferLen);
-          }
-        }
-      }
-    }
-
-    /* C-plane DL */
-    printf("wrapper.hpp: Init memory *** XRANFTHTX_SEC_DESC_OUT ***\n");
-    eInterfaceType = XRANFTHTX_SEC_DESC_OUT;
-    status = xran_bm_init(m_nInstanceHandle[0][i],
-                          &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType],
-                          XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT * XRAN_MAX_SECTIONS_PER_SYM,
-                          sizeof(struct xran_section_desc));
-    if (XRAN_STATUS_SUCCESS != status) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    printf("wrapper.hpp: Init memory *** XRANFTHTX_PRB_MAP_OUT ***\n");
-    eInterfaceType = XRANFTHTX_PRB_MAP_OUT;
-    status =
-        xran_bm_init(m_nInstanceHandle[0][i], &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT, sizeof(struct xran_prb_map));
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFrontHaulTxPrbMapBuffers[j][i][z];
-
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes = sizeof(struct xran_prb_map);
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements = 1;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes = 0;
-        status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-        if (status != XRAN_STATUS_SUCCESS) {
-          std::cout << __LINE__ << " Failed at xran_bm_allocate_buffer, status " << status << std::endl;
-          return (-1);
-        }
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData = (uint8_t *)ptr;
-        m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl = (void *)mb;
-        void *sd_ptr;
-        void *sd_mb;
-        int elm_id;
-        struct xran_prb_map *p_rb_map = (struct xran_prb_map *)ptr;
-        for (elm_id = 0; elm_id < XRAN_MAX_SECTIONS_PER_SYM; elm_id++) {
-          struct xran_prb_elm *pPrbElem = &p_rb_map->prbMap[elm_id];
-          for (k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
-            status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][XRANFTHTX_SEC_DESC_OUT], &sd_ptr, &sd_mb);
-            if (XRAN_STATUS_SUCCESS != status) {
-              std::cout << __LINE__ << "SD Failed at  xran_bm_allocate_buffer , status %d\n" << status << std::endl;
-              return (-1);
-            }
-            pPrbElem->p_sec_desc[k] = (struct xran_section_desc *)sd_ptr;
-          }
-        }
-      }
-    }
-  }
-
-  for (i = 0; i < nSectorNum; i++) {
-    printf("wrapper.hpp: Init memory *** XRANFTHRX_IN ***\n");
-    eInterfaceType = XRANFTHRX_IN;
-    status = xran_bm_init(m_nInstanceHandle[0][i],
-                          &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType],
-                          XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
-                          m_nSW_ToFpga_FTH_TxBufferLen); /* ????, actual alloc size is m_nFpgaToSW_FTH_RxBUfferLen */
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
-        m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFrontHaulRxBuffers[j][i][z][0];
-        for (k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
-          m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes = m_nFpgaToSW_FTH_RxBufferLen;
-          m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements = 1;
-          m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes = 0;
-          status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-          if (status != XRAN_STATUS_SUCCESS) {
-            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
-            return (-1);
-          }
-          m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
-          m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
-          if (ptr) {
-            u32dptr = (uint32_t *)(ptr);
-            memset(u32dptr, 0x0, m_nFpgaToSW_FTH_RxBufferLen);
-          }
-        }
-      }
-    }
-    printf("wrapper.hpp: Init memory *** XRANFTHTX_SEC_DESC_IN ***\n");
-    eInterfaceType = XRANFTHTX_SEC_DESC_IN;
-    status = xran_bm_init(m_nInstanceHandle[0][i],
-                          &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType],
-                          XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT * XRAN_MAX_SECTIONS_PER_SYM,
-                          sizeof(struct xran_section_desc));
-    if (XRAN_STATUS_SUCCESS != status) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    printf("wrapper.hpp: Init memory *** XRANFTHRX_PRB_MAP_IN ***\n");
-    eInterfaceType = XRANFTHRX_PRB_MAP_IN;
-    status =
-        xran_bm_init(m_nInstanceHandle[0][i], &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT, sizeof(struct xran_prb_map));
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFrontHaulRxPrbMapBuffers[j][i][z];
-
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes = sizeof(struct xran_prb_map);
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements = 1;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes = 0;
-        status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-        if (status != XRAN_STATUS_SUCCESS) {
-          std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer , status " << status << std::endl;
-          return (-1);
-        }
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData = (uint8_t *)ptr;
-        m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl = (void *)mb;
-        void *sd_ptr;
-        void *sd_mb;
-        int elm_id;
-        struct xran_prb_map *p_rb_map = (struct xran_prb_map *)ptr;
-        for (elm_id = 0; elm_id < XRAN_MAX_SECTIONS_PER_SYM; elm_id++) {
-          struct xran_prb_elm *pPrbElem = &p_rb_map->prbMap[elm_id];
-          for (k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
-            status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][XRANFTHTX_SEC_DESC_IN], &sd_ptr, &sd_mb);
-            if (XRAN_STATUS_SUCCESS != status) {
-              std::cout << __LINE__ << "SD Failed at  xran_bm_allocate_buffer , status %d\n" << status << std::endl;
-              return (-1);
-            }
-            pPrbElem->p_sec_desc[k] = (struct xran_section_desc *)sd_ptr;
-          }
-        }
-      }
-    }
-  }
-
-  for (i = 0; i < nSectorNum; i++) {
-    printf("wrapper.hpp: Init memory *** XRANFTHRACH_IN ***\n");
-    eInterfaceType = XRANFTHRACH_IN;
-    status = xran_bm_init(
-        m_nInstanceHandle[0][i], &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT, FPGA_TO_SW_PRACH_RX_BUFFER_LEN);
-    if (status != XRAN_STATUS_SUCCESS) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = xran_max_antenna_nr;
-        m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFHPrachRxBuffers[j][i][z][0];
-        for (k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
-          m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes = FPGA_TO_SW_PRACH_RX_BUFFER_LEN;
-          m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements = 1;
-          m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes = 0;
-          status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-          if (status != XRAN_STATUS_SUCCESS) {
-            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
-            return (-1);
-          }
-          m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
-          m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
-          if (ptr) {
-            u32dptr = (uint32_t *)(ptr);
-            memset(u32dptr, 0x0, FPGA_TO_SW_PRACH_RX_BUFFER_LEN);
-          }
-        }
-      }
-    }
-  }
-
-  /* Insert the allocation of srs buffers useful for xran_5g_srs_req()
-     Code taken from sample app */
-
-  /* Add SRS rx buffer */
-  for (i = 0; i < nSectorNum && xran_max_ant_array_elm_nr; i++) {
-    printf("wrapper.hpp: Init memory *** XRANSRS_IN ***\n");
-    eInterfaceType = XRANSRS_IN;
-    status = xran_bm_init(m_nInstanceHandle[0][i],
-                          &m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType],
-                          XRAN_N_FE_BUF_LEN * xran_max_ant_array_elm_nr * XRAN_MAX_NUM_OF_SRS_SYMBOL_PER_SLOT,
-                          m_nSW_ToFpga_FTH_TxBufferLen);
-
-    if (XRAN_STATUS_SUCCESS != status) {
-      std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
-      return (-1);
-    }
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_ant_array_elm_nr; z++) {
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].bValid = 0;
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = xran_max_ant_array_elm_nr; /* ant number */
-        m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &m_sFHSrsRxBuffers[j][i][z][0];
-        for (k = 0; k < XRAN_MAX_NUM_OF_SRS_SYMBOL_PER_SLOT; k++) {
-          m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes = m_nSW_ToFpga_FTH_TxBufferLen;
-          m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements = 1;
-          m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes = 0;
-          status = xran_bm_allocate_buffer(m_nInstanceHandle[0][i], m_nBufPoolIndex[m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
-          if (XRAN_STATUS_SUCCESS != status) {
-            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
-            return (-1);
-          }
-          m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
-          m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
-          if (ptr) {
-            u32dptr = (uint32_t *)(ptr);
-            memset(u32dptr, 0x0, m_nSW_ToFpga_FTH_TxBufferLen);
-          }
-        }
-      }
-    }
-  }
-  return (0);
-}
-
-// Class Constructor
-xranLibWraper::xranLibWraper()
-{
-  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-  // Put here all the variables that are hard coded and assign them to a variable.
-  // This should then be changed to a dynamic config
-  // At least for now we group all the hard coded value we want to get rid of them
-  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-  // From xran_io_cfg of xran_fh_o_du.h
-  uint8_t id_ = 0;
-  uint8_t num_vfs_ = 2;
-
-  // From xran_eaxcid_config of xran_fh_o_du.h
-  uint8_t bit_cuPortId_ = 12; //(??) bitnum_bandsec + bitnum_ccid + bitnum_ruport;
-  uint8_t bit_bandSectorId_ = 8; //(??) bitnum_ccid + bitnum_ruport;
-  uint8_t bit_ccId_ = 4; //(??) bitnum_ruport;
-  uint8_t bit_ruPortId_ = 0;
-  uint16_t mask_cuPortId_ = 0xf000; // get_eaxcid_mask(bitnum_cuport, m_xranInit.eAxCId_conf.bit_cuPortId);
-  uint16_t mask_bandSectorId_ = 0x0f00; // get_eaxcid_mask(bitnum_bandsec, m_xranInit.eAxCId_conf.bit_bandSectorId);
-  uint16_t mask_ccId_ = 0x00f0; // get_eaxcid_mask(bitnum_ccid, m_xranInit.eAxCId_conf.bit_ccId);
-  uint16_t mask_ruPortId_ = 0x000f; // get_eaxcid_mask(bitnum_ruport, m_xranInit.eAxCId_conf.bit_ruPortId);
-
-  // From xran_fh_init of xran_fh_o_du.h
-  uint8_t enableCP_ = 1;
-  uint8_t prachEnable_ = 1;
-  int32_t debugStop_ = 0;
-  int32_t debugStopCount_ = 0;
-  int32_t DynamicSectionEna_ = 0;
-  const char *filePrefix_ = "wls";
-
-  // Independent
-  m_nSlots = 0;
-  m_du_mac[0] = 0x00;
-  m_du_mac[1] = 0x11;
-  m_du_mac[2] = 0x22;
-  m_du_mac[3] = 0x33;
-  m_du_mac[4] = 0x44;
-  m_du_mac[5] = 0x55;
-
-  int i, temp, j;
-  std::string tmpstr;
-  unsigned int tmp_mac[6];
-
-  m_global_cfg = read_json_from_file(XRAN_UT_CFG_FILENAME);
-
-  memset(&m_xranInit, 0, sizeof(xran_fh_init));
-
-  m_xranInit.io_cfg.id = id_;
-
-  /* DPDK configuration */
-  m_dpdk_dev_up = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdk_dev_up");
-  m_dpdk_dev_cp = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdk_dev_cp");
-  m_xranInit.io_cfg.dpdk_dev[XRAN_CP_VF] = (m_dpdk_dev_cp == "") ? NULL : (char *)&m_dpdk_dev_cp[0];
-  m_xranInit.io_cfg.dpdk_dev[XRAN_UP_VF] = (m_dpdk_dev_cp == "") ? NULL : (char *)&m_dpdk_dev_up[0];
-  std::cout << "UP_VF [" << m_xranInit.io_cfg.dpdk_dev[XRAN_UP_VF] << "], CP_VF [" << m_xranInit.io_cfg.dpdk_dev[XRAN_CP_VF] << "]" << std::endl;
-  m_xranInit.io_cfg.num_vfs = num_vfs_;
-
-  printf(
-      "wrapper.hpp: m_xranInit.io_cfg.dpdk_dev[%d] =%s, m_xranInit.io_cfg.dpdk_dev[%d]=%s\n", XRAN_UP_VF, m_xranInit.io_cfg.dpdk_dev[XRAN_UP_VF], XRAN_CP_VF, m_xranInit.io_cfg.dpdk_dev[XRAN_CP_VF]);
-
-  m_xranInit.io_cfg.core = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "core");
-  m_xranInit.io_cfg.system_core = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "system_core");
-  uint8_t tmp_pkt_proc_core = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "pkt_proc_core");
-  m_xranInit.io_cfg.pkt_proc_core = (uint64_t)1 << tmp_pkt_proc_core;
-  m_xranInit.io_cfg.pkt_aux_core = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "pkt_aux_core");
-  m_xranInit.io_cfg.timing_core = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "timing_core");
-
-  std::string bbdev_mode = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "bbdev_mode");
-  if (bbdev_mode == "sw")
-    m_xranInit.io_cfg.bbdev_mode = XRAN_BBDEV_MODE_HW_OFF;
-  else if (bbdev_mode == "hw")
-    m_xranInit.io_cfg.bbdev_mode = XRAN_BBDEV_MODE_HW_ON;
-  else if (bbdev_mode == "none")
-    m_xranInit.io_cfg.bbdev_mode = XRAN_BBDEV_NOT_USED;
-  else {
-    std::cout << "Invalid BBDev mode [" << bbdev_mode << "], bbdev won't be used." << std::endl;
-    m_xranInit.io_cfg.bbdev_mode = XRAN_BBDEV_NOT_USED;
-  }
-
-  m_xranInit.dpdkBasebandFecMode = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdkBasebandFecMode");
-
-  m_dpdk_bbdev = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdkBasebandDevice");
-  m_xranInit.dpdkBasebandDevice = (m_dpdk_bbdev == "") ? NULL : (char *)&m_dpdk_bbdev;
-
-  /* Network configurations */
-  m_xranInit.mtu = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "mtu");
-
-  std::string du_mac_str = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "o_du_macaddr");
-  std::string ru_mac_str = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "o_ru_macaddr");
-  /* using temp variables to resolve KW issue */
-  std::sscanf(du_mac_str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x", &tmp_mac[0], &tmp_mac[1], &tmp_mac[2], &tmp_mac[3], &tmp_mac[4], &tmp_mac[5]);
-  for (i = 0; i < 6; i++)
-    m_du_mac[i] = (uint8_t)tmp_mac[i];
-  std::sscanf(ru_mac_str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x", &tmp_mac[0], &tmp_mac[1], &tmp_mac[2], &tmp_mac[3], &tmp_mac[4], &tmp_mac[5]);
-  for (j = 0; j < XRAN_VF_MAX; j++) {
-    for (i = 0; i < 6; i++)
-      m_ru_mac[j][i] = (uint8_t)tmp_mac[i];
-  }
-  m_xranInit.p_o_du_addr = (int8_t *)m_du_mac;
-  m_xranInit.p_o_ru_addr = (int8_t *)m_ru_mac;
-  m_xranInit.cp_vlan_tag = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "cp_vlan_tag");
-  m_xranInit.up_vlan_tag = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "up_vlan_tag");
-
-  /* eAxCID configurations */
-  // int bitnum_cuport   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_cuPortId"); // Hard C
-  // int bitnum_bandsec  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_bandSectorId"); //Hard C
-  // int bitnum_ccid     = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_ccId"); //Hard C
-  // int bitnum_ruport   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_ruPortId"); //Hard C
-
-  m_xranInit.eAxCId_conf.bit_cuPortId = bit_cuPortId_;
-  m_xranInit.eAxCId_conf.bit_bandSectorId = bit_bandSectorId_;
-  m_xranInit.eAxCId_conf.bit_ccId = bit_ccId_;
-  m_xranInit.eAxCId_conf.bit_ruPortId = bit_ruPortId_;
-  m_xranInit.eAxCId_conf.mask_cuPortId = mask_cuPortId_;
-  m_xranInit.eAxCId_conf.mask_bandSectorId = mask_bandSectorId_;
-  m_xranInit.eAxCId_conf.mask_ccId = mask_ccId_;
-  m_xranInit.eAxCId_conf.mask_ruPortId = mask_ruPortId_;
-
-  m_xranInit.totalBfWeights = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "totalBfWeights");
-
-  m_xranInit.Tadv_cp_dl = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Tadv_cp_dl");
-  m_xranInit.T2a_min_cp_dl = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_cp_dl");
-  m_xranInit.T2a_max_cp_dl = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_cp_dl");
-  m_xranInit.T2a_min_cp_ul = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_cp_ul");
-  m_xranInit.T2a_max_cp_ul = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_cp_ul");
-  m_xranInit.T2a_min_up = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_up");
-  m_xranInit.T2a_max_up = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_up");
-  m_xranInit.Ta3_min = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta3_min");
-  m_xranInit.Ta3_max = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta3_max");
-  m_xranInit.T1a_min_cp_dl = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_cp_dl");
-  m_xranInit.T1a_max_cp_dl = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_cp_dl");
-  m_xranInit.T1a_min_cp_ul = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_cp_ul");
-  m_xranInit.T1a_max_cp_ul = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_cp_ul");
-  m_xranInit.T1a_min_up = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_up");
-  m_xranInit.T1a_max_up = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_up");
-  m_xranInit.Ta4_min = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta4_min");
-  m_xranInit.Ta4_max = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta4_max");
-
-  m_xranInit.enableCP = enableCP_;
-  m_xranInit.prachEnable = prachEnable_;
-  m_xranInit.debugStop = debugStop_;
-  m_xranInit.debugStopCount = debugStopCount_;
-  m_xranInit.DynamicSectionEna = DynamicSectionEna_;
-
-  m_xranInit.filePrefix = const_cast<char *>(filePrefix_);
-
-  m_bSub6 = get_globalcfg<bool>(XRAN_UT_KEY_GLOBALCFG_RU, "sub6");
-
-  memset(&m_xranConf, 0, sizeof(struct xran_fh_config));
-  tmpstr = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "duplex");
-  if (tmpstr == "FDD") {
-    m_xranConf.frame_conf.nFrameDuplexType = 0;
-  } else if (tmpstr == "TDD") {
-    m_xranConf.frame_conf.nFrameDuplexType = 1;
-
-    std::string slotcfg_key = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "slot_config");
-
-    int numcfg = get_globalcfg<int>(slotcfg_key, "period");
-    m_xranConf.frame_conf.nTddPeriod = numcfg;
-
-    for (int i = 0; i < numcfg; i++) {
-      std::stringstream slotcfgname;
-      slotcfgname << "slot" << i;
-      std::vector<int> slotcfg = get_globalcfg_array<int>(slotcfg_key, slotcfgname.str());
-      for (uint16_t j = 0; j < slotcfg.size(); j++) {
-        m_xranConf.frame_conf.sSlotConfig[i].nSymbolType[j] = slotcfg[j];
-      }
-      m_xranConf.frame_conf.sSlotConfig[i].reserved[0] = 0;
-      m_xranConf.frame_conf.sSlotConfig[i].reserved[1] = 0;
-    }
-  } else {
-    std::cout << "*** Invalid Duplex type [" << tmpstr << "] !!!" << std::endl;
-    std::cout << "****** Set it to FDD... " << std::endl;
-    m_xranConf.frame_conf.nFrameDuplexType = 0;
-  }
-
-  m_xranConf.frame_conf.nNumerology = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "mu");
-  if (m_xranConf.frame_conf.nNumerology > 3) {
-    std::cout << "*** Invalid Numerology [" << m_xranConf.frame_conf.nNumerology << "] !!!" << std::endl;
-    m_xranConf.frame_conf.nNumerology = 1;
-    std::cout << "****** Setting it to " << m_xranConf.frame_conf.nNumerology << "..." << std::endl;
-  }
-
-  switch (m_xranConf.frame_conf.nNumerology) {
-    case 0: /* Numerology - 0 */
-      m_nSlots = 10;
-      break;
-    case 1: /* Numerology - 1 */
-      m_nSlots = 20;
-      break;
-    case 2: /* Numerology - 2 */
-      m_nSlots = 40;
-      break;
-    case 3: /* Numerology - 3 */
-      m_nSlots = 80;
-      break;
-  }
-  std::cout << "*** Numerology [" << m_xranConf.frame_conf.nNumerology << "] " << std::endl;
-  std::cout << "*** Number of Slot [" << m_nSlots << "] " << std::endl;
-
-  m_xranConf.nCC = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "num_cc");
-  if (m_xranConf.nCC > XRAN_MAX_SECTOR_NR) {
-    std::cout << "*** Exceeds maximum number of carriers supported [" << m_xranConf.nCC << "] !!!" << std::endl;
-    m_xranConf.nCC = XRAN_MAX_SECTOR_NR;
-    std::cout << "****** Adjusted to " << m_xranConf.nCC << "..." << std::endl;
-  }
-  m_xranConf.neAxc = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "num_eaxc");
-  if (m_xranConf.neAxc > XRAN_MAX_ANTENNA_NR) {
-    std::cout << "*** Exceeds maximum number of antenna supported [" << m_xranConf.neAxc << "] !!!" << std::endl;
-    m_xranConf.neAxc = XRAN_MAX_ANTENNA_NR;
-    std::cout << "****** Adjusted to " << m_xranConf.neAxc << "..." << std::endl;
-  }
-
-  m_bSub6 = get_globalcfg<bool>(XRAN_UT_KEY_GLOBALCFG_RU, "sub6");
-  temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "chbw_dl");
-  m_xranConf.nDLRBs = get_num_rbs(get_numerology(), temp, m_bSub6);
-  temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "chbw_ul");
-  m_xranConf.nULRBs = get_num_rbs(get_numerology(), temp, m_bSub6);
-
-  m_xranConf.nAntElmTRx = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "ant_elm_trx");
-  m_xranConf.nDLFftSize = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
-  m_xranConf.nULFftSize = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
-
-  m_xranConf.prach_conf.nPrachConfIdx = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "config_id");
-  m_xranConf.prach_conf.nPrachSubcSpacing = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "scs");
-  m_xranConf.prach_conf.nPrachFreqStart = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "freq_start");
-  m_xranConf.prach_conf.nPrachFreqOffset = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "freq_offset");
-  m_xranConf.prach_conf.nPrachFilterIdx = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "filter_id");
-  m_xranConf.prach_conf.nPrachZeroCorrConf = 0;
-  m_xranConf.prach_conf.nPrachRestrictSet = 0;
-  m_xranConf.prach_conf.nPrachRootSeqIdx = 0;
-
-  tmpstr = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "category");
-  if (tmpstr == "A")
-    m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_A;
-  else if (tmpstr == "B")
-    m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_B;
-  else {
-    std::cout << "*** Invalid RU Category [" << tmpstr << "] !!!" << std::endl;
-    std::cout << "****** Set it to Category A... " << std::endl;
-    m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_A;
-  }
-
-  m_xranConf.ru_conf.iqWidth = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "iq_width");
-  std::cout << "*** IQ Width [" << m_xranConf.ru_conf.iqWidth << "]" << std::endl;
-  m_xranConf.ru_conf.compMeth = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "comp_meth");
-  std::cout << "*** Compression Method [" << m_xranConf.ru_conf.compMeth << "]" << std::endl;
-
-  temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
-  m_xranConf.ru_conf.fftSize = 0;
-  while (temp >>= 1)
-    ++m_xranConf.ru_conf.fftSize;
-
-  m_xranConf.ru_conf.byteOrder = XRAN_NE_BE_BYTE_ORDER;
-  m_xranConf.ru_conf.iqOrder = XRAN_I_Q_ORDER;
-
-  m_xranConf.log_level = 1;
-}
-
-// Class Destructor
-xranLibWraper::~xranLibWraper()
-{
-}
-
-int xranLibWraper::SetUp()
-{
-  int i;
-
-  printf("O-DU MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
-         m_xranInit.p_o_du_addr[0],
-         m_xranInit.p_o_du_addr[1],
-         m_xranInit.p_o_du_addr[2],
-         m_xranInit.p_o_du_addr[3],
-         m_xranInit.p_o_du_addr[4],
-         m_xranInit.p_o_du_addr[5]);
-
-  printf("O-RU MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
-         m_xranInit.p_o_ru_addr[0],
-         m_xranInit.p_o_ru_addr[1],
-         m_xranInit.p_o_ru_addr[2],
-         m_xranInit.p_o_ru_addr[3],
-         m_xranInit.p_o_ru_addr[4],
-         m_xranInit.p_o_ru_addr[5]);
-
-  printf("eAxCID - %d:%d:%d:%d (%04x, %04x, %04x, %04x)\n",
-         m_xranInit.eAxCId_conf.bit_cuPortId,
-         m_xranInit.eAxCId_conf.bit_bandSectorId,
-         m_xranInit.eAxCId_conf.bit_ccId,
-         m_xranInit.eAxCId_conf.bit_ruPortId,
-         m_xranInit.eAxCId_conf.mask_cuPortId,
-         m_xranInit.eAxCId_conf.mask_bandSectorId,
-         m_xranInit.eAxCId_conf.mask_ccId,
-         m_xranInit.eAxCId_conf.mask_ruPortId);
-
-  printf("Total BF Weights : %d\n", m_xranInit.totalBfWeights);
-
-  xran_init(0, NULL, &m_xranInit, &argv[0], &m_xranhandle);
-
-  for (i = 0; i < XRAN_MAX_SECTOR_NR; i++)
-    m_nSectorIndex[i] = i;
-
-  /* set to maximum length to support multiple cases */
-  m_nFpgaToSW_FTH_RxBufferLen = 13168; /* 273*12*4 + 64*/
-
-  m_nSW_ToFpga_FTH_TxBufferLen =
-      13168 + /* 273*12*4 + 64* + ETH AND ORAN HDRs */
-      XRAN_MAX_SECTIONS_PER_SYM * (RTE_PKTMBUF_HEADROOM + sizeof(struct rte_ether_hdr) + sizeof(struct xran_ecpri_hdr) + sizeof(struct radio_app_common_hdr) + sizeof(struct data_section_hdr));
-  printf("wrapper.hpp: nFpgaToSW_FTH_RxBufferLen=%d , nSW_ToFpga_FTH_TxBufferLen=%d\n", m_nFpgaToSW_FTH_RxBufferLen, m_nSW_ToFpga_FTH_TxBufferLen);
-
-  if (init_memory() < 0) {
-    std::cout << "Fatal Error on Initialization !!!" << std::endl;
-    std::cout << "INIT FAILED" << std::endl;
-    return (-1);
-  }
-
-  std::cout << "INIT DONE" << std::endl;
-  return (0);
-}
-
-void xranLibWraper::TearDown()
-{
-  if (m_xranhandle) {
-    xran_close(m_xranhandle);
-    m_xranhandle = nullptr;
-    std::cout << "CLOSE DONE" << std::endl;
-  } else
-    std::cout << "ALREADY CLOSED" << std::endl;
-}
-
-//------------------------------------------------------------------------------------------------------------------------------------------------
-int xranLibWraper::Init(struct xran_fh_config *pCfg)
-{
-  int32_t nSectorNum;
-  uint32_t i;
-  int32_t cc_id, tti;
-  uint32_t ant_id;
-  struct xran_prb_map *pRbMap = NULL;
-
-  uint32_t xran_max_antenna_nr = RTE_MAX(get_num_eaxc(), get_num_eaxc_ul());
-  uint8_t symbol_counter = 0;
-  uint8_t symbol_config = 0;
-  uint8_t mixed_slot = 0;
-  uint8_t mixed_slot_dl_symbol = 0;
-  uint8_t mixed_slot_dl_start_symbol = 0;
-  bool mixed_slot_dl_start_symbol_found = 0;
-  uint8_t mixed_slot_ul_symbol = 0;
-  uint8_t mixed_slot_ul_start_symbol = 0;
-  bool mixed_slot_ul_start_symbol_found = 0;
-  uint8_t mixed_slot_gaurd_symbol = 0;
-  uint8_t mixed_slot_tti_index[40];
-
-  /* Update member variables */
-  if (pCfg)
-    memcpy(&m_xranConf, pCfg, sizeof(struct xran_fh_config));
-
-  /* Init timer context */
-  xran_lib_ota_tti = 0;
-  xran_lib_ota_sym = 0;
-  xran_lib_ota_sym_idx = 0;
-  for (i = 0; i < MAX_NUM_OF_XRAN_CTX; i++)
-    m_timer_ctx[i].tti_to_process = i;
-
-  nSectorNum = get_num_cc();
-
-  /* Cat B RU support */
-  if (get_rucategory() == XRAN_CATEGORY_B) {
-    /* 10 * [14*32*273*2*2] = 4892160 bytes */
-    iq_bfw_buffer_size_dl = (m_nSlots * N_SYM_PER_SLOT * get_num_antelmtrx() * get_num_dlrbs() * 4L);
-    iq_bfw_buffer_size_ul = (m_nSlots * N_SYM_PER_SLOT * get_num_antelmtrx() * get_num_ulrbs() * 4L);
-
-    for (i = 0; i < MAX_ANT_CARRIER_SUPPORTED && i < (uint32_t)(get_num_cc() * get_num_eaxc()); i++) {
-      p_tx_dl_bfw_buffer[i] = (int16_t *)malloc(iq_bfw_buffer_size_dl);
-      tx_dl_bfw_buffer_size[i] = (int32_t)iq_bfw_buffer_size_dl;
-      if (p_tx_dl_bfw_buffer[i] == NULL)
-        return (-1);
-
-      memset(p_tx_dl_bfw_buffer[i], 'D', iq_bfw_buffer_size_dl);
-      tx_dl_bfw_buffer_position[i] = 0;
-
-      p_tx_ul_bfw_buffer[i] = (int16_t *)malloc(iq_bfw_buffer_size_ul);
-      tx_ul_bfw_buffer_size[i] = (int32_t)iq_bfw_buffer_size_ul;
-      if (p_tx_ul_bfw_buffer[i] == NULL)
-        return (-1);
-
-      memset(p_tx_ul_bfw_buffer[i], 'U', iq_bfw_buffer_size_ul);
-      tx_ul_bfw_buffer_position[i] = 0;
-    }
-  }
-
-  for (uint8_t period_counter = 0; period_counter < m_xranConf.frame_conf.nTddPeriod; period_counter++) {
-    uint8_t symbol;
-    symbol_config = m_xranConf.frame_conf.sSlotConfig[period_counter].nSymbolType[0];
-
-    for (symbol = 0; symbol < 14; symbol++) {
-      if (symbol_config == m_xranConf.frame_conf.sSlotConfig[period_counter].nSymbolType[symbol])
-        symbol_counter++;
-    }
-
-    if (symbol_counter != 14) {
-      mixed_slot = period_counter;
-      symbol = 0;
-      while (symbol < 14) {
-        switch (m_xranConf.frame_conf.sSlotConfig[period_counter].nSymbolType[symbol]) {
-          case 0: /* DL Symbol */
-            if (!mixed_slot_dl_start_symbol_found) {
-              mixed_slot_dl_start_symbol_found = 1;
-              mixed_slot_dl_start_symbol = symbol;
-            }
-            mixed_slot_dl_symbol++;
-            break;
-          case 1: /* UL Symbol */
-            if (!mixed_slot_ul_start_symbol_found) {
-              mixed_slot_ul_start_symbol_found = 1;
-              mixed_slot_ul_start_symbol = symbol;
-            }
-            mixed_slot_ul_symbol++;
-            break;
-          default: /* Guard Period */
-            mixed_slot_gaurd_symbol++;
-        }
-        symbol++;
-      }
-      break;
-    }
-    symbol_counter = 0;
-    printf("\n");
-  }
-
-  memset(mixed_slot_tti_index, 0, sizeof(mixed_slot_tti_index));
-  mixed_slot_tti_index[mixed_slot] = 1;
-
-  for (uint8_t kk = 1; kk < (XRAN_N_FE_BUF_LEN / m_xranConf.frame_conf.nTddPeriod); kk++) {
-    mixed_slot_tti_index[kk * (m_xranConf.frame_conf.nTddPeriod) + mixed_slot] = 1;
-  }
-
-  /* Init RB map */
-  for (cc_id = 0; cc_id < nSectorNum; cc_id++) {
-    for (tti = 0; tti < XRAN_N_FE_BUF_LEN; tti++) {
-      for (ant_id = 0; ant_id < xran_max_antenna_nr; ant_id++) {
-        //  flowId = xran_max_antenna_nr*cc_id + ant_id;
-
-        /* C-plane DL */
-        pRbMap = (struct xran_prb_map *)m_sFrontHaulTxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
-        if (pRbMap) {
-          pRbMap->dir = XRAN_DIR_DL;
-          pRbMap->xran_port = 0;
-          pRbMap->band_id = 0;
-          pRbMap->cc_id = cc_id;
-          pRbMap->ru_port_id = ant_id;
-          pRbMap->tti_id = tti;
-          pRbMap->start_sym_id = 0;
-
-          pRbMap->nPrbElm = 1;
-          pRbMap->prbMap[0].nRBStart = 0;
-          pRbMap->prbMap[0].nRBSize = get_num_dlrbs();
-          if (mixed_slot_tti_index[tti]) {
-            pRbMap->prbMap[0].nStartSymb = mixed_slot_dl_start_symbol;
-            pRbMap->prbMap[0].numSymb = mixed_slot_dl_symbol;
-          } else {
-            pRbMap->prbMap[0].nStartSymb = 0;
-            pRbMap->prbMap[0].numSymb = 14;
-          }
-          pRbMap->prbMap[0].nBeamIndex = 0;
-          /* Update according to the target compression in oran.fhi.json */
-          pRbMap->prbMap[0].compMethod = m_xranConf.ru_conf.compMeth; /* xran_compression_method */
-          /* Update according to the target compression in oran.fhi.json */
-          pRbMap->prbMap[0].iqWidth = m_xranConf.ru_conf.iqWidth;
-
-          if (get_rucategory() == XRAN_CATEGORY_A) {
-            pRbMap->prbMap[0].BeamFormingType = XRAN_BEAM_ID_BASED;
-            pRbMap->prbMap[0].bf_weight_update = 0;
-          } else if (get_rucategory() == XRAN_CATEGORY_B) {
-            pRbMap->prbMap[0].BeamFormingType = XRAN_BEAM_WEIGHT;
-            pRbMap->prbMap[0].bf_weight_update = 1;
-
-          } /* else if(get_rucategory() == XRAN_CATEGORY_B) */
-        } /* if(pRbMap) */
-        else {
-          std::cout << "DL pRbMap ==NULL" << std::endl;
-        }
-
-        /* C-plane UL */
-        pRbMap = (struct xran_prb_map *)m_sFrontHaulRxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
-        if (pRbMap) {
-          pRbMap->dir = XRAN_DIR_UL;
-          pRbMap->xran_port = 0;
-          pRbMap->band_id = 0;
-          pRbMap->cc_id = cc_id;
-          pRbMap->ru_port_id = ant_id;
-          pRbMap->tti_id = tti;
-          pRbMap->start_sym_id = 0;
-
-          pRbMap->nPrbElm = 1;
-          pRbMap->prbMap[0].nRBStart = 0;
-          pRbMap->prbMap[0].nRBSize = get_num_ulrbs();
-          if (mixed_slot_tti_index[tti]) {
-            pRbMap->prbMap[0].nStartSymb = mixed_slot_ul_start_symbol;
-            pRbMap->prbMap[0].numSymb = mixed_slot_ul_symbol;
-          } else {
-            pRbMap->prbMap[0].nStartSymb = 0;
-            pRbMap->prbMap[0].numSymb = 14;
-          }
-          pRbMap->prbMap[0].nBeamIndex = 0;
-          /* xran_compression_method */
-          /* Modify according to the target compression from oran.fhi.json */
-          pRbMap->prbMap[0].compMethod = m_xranConf.ru_conf.compMeth;
-          /* Update IQ-Width based on oran.fhi.json */
-          pRbMap->prbMap[0].iqWidth = m_xranConf.ru_conf.iqWidth;
-
-          if (get_rucategory() == XRAN_CATEGORY_A) {
-            pRbMap->prbMap[0].BeamFormingType = XRAN_BEAM_ID_BASED;
-            pRbMap->prbMap[0].bf_weight_update = 0;
-          } else if (get_rucategory() == XRAN_CATEGORY_B) {
-            pRbMap->prbMap[0].BeamFormingType = XRAN_BEAM_WEIGHT;
-            pRbMap->prbMap[0].bf_weight_update = 1;
-
-          } /* else if(get_rucategory() == XRAN_CATEGORY_B) */
-
-        } /* if(pRbMap) */
-        else {
-          std::cout << "UL: pRbMap ==NULL" << std::endl;
-        }
-      }
-    }
-  }
-
-  return (0);
-}
-
-void xranLibWraper::Cleanup()
-{
-  uint32_t i;
-
-  if (get_rucategory() == XRAN_CATEGORY_B) {
-    for (i = 0; i < MAX_ANT_CARRIER_SUPPORTED && i < (uint32_t)(get_num_cc() * get_num_eaxc()); i++) {
-      if (p_tx_dl_bfw_buffer[i]) {
-        free(p_tx_dl_bfw_buffer[i]);
-        p_tx_dl_bfw_buffer[i] = NULL;
-      }
-
-      if (p_tx_ul_bfw_buffer[i]) {
-        free(p_tx_ul_bfw_buffer[i]);
-        p_tx_ul_bfw_buffer[i] = NULL;
-      }
-    }
-  }
-
-  return;
-}
-
-void xranLibWraper::Open(xran_ethdi_mbuf_send_fn send_cp, xran_ethdi_mbuf_send_fn send_up, void *fh_rx_callback, void *fh_rx_prach_callback, void *fh_srs_callback)
-{
-  int32_t nSectorNum;
-  int i, j;
-  uint32_t z;
-
-  uint32_t xran_max_antenna_nr = RTE_MAX(get_num_eaxc(), get_num_eaxc_ul());
-  uint32_t xran_max_ant_array_elm_nr = RTE_MAX(get_num_antelmtrx(), xran_max_antenna_nr);
-
-  struct xran_buffer_list *pFthTxBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
-  struct xran_buffer_list *pFthTxPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
-  struct xran_buffer_list *pFthRxBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
-  struct xran_buffer_list *pFthRxPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
-  struct xran_buffer_list *pFthRxRachBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
-  struct xran_buffer_list *pFthRxSrsBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_N_FE_BUF_LEN];
-
-  nSectorNum = get_num_cc();
-
-  for (i = 0; i < nSectorNum; i++) {
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < XRAN_MAX_ANTENNA_NR; z++) {
-        pFthTxBuffer[i][z][j] = NULL;
-        pFthTxPrbMapBuffer[i][z][j] = NULL;
-        pFthRxBuffer[i][z][j] = NULL;
-        pFthRxPrbMapBuffer[i][z][j] = NULL;
-        pFthRxRachBuffer[i][z][j] = NULL;
-      }
-      for (z = 0; z < xran_max_ant_array_elm_nr; z++) {
-        pFthRxSrsBuffer[i][z][j] = NULL;
-      }
-    }
-  }
-
-  for (i = 0; i < nSectorNum; i++) {
-    for (j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
-      for (z = 0; z < xran_max_antenna_nr; z++) {
-        pFthTxBuffer[i][z][j] = &(m_sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList);
-        pFthTxPrbMapBuffer[i][z][j] = &(m_sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
-        pFthRxBuffer[i][z][j] = &(m_sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList);
-        pFthRxPrbMapBuffer[i][z][j] = &(m_sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
-        pFthRxRachBuffer[i][z][j] = &(m_sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList);
-      }
-      for (z = 0; z < xran_max_ant_array_elm_nr && xran_max_ant_array_elm_nr; z++) {
-        pFthRxSrsBuffer[i][z][j] = &(m_sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList);
-      }
-    }
-  }
-
-  if (m_nInstanceHandle[0] != NULL) {
-    for (i = 0; i < nSectorNum; i++) {
-      xran_5g_fronthault_config(
-          m_nInstanceHandle[0][i], pFthTxBuffer[i], pFthTxPrbMapBuffer[i], pFthRxBuffer[i], pFthRxPrbMapBuffer[i], (void (*)(void *, xran_status_t))fh_rx_callback, &pFthRxBuffer[i][0]);
-
-      xran_5g_prach_req(m_nInstanceHandle[0][i], pFthRxRachBuffer[i], (void (*)(void *, xran_status_t))fh_rx_prach_callback, &pFthRxRachBuffer[i][0]);
-    }
-
-    /* add SRS callback here */
-  }
-  xran_register_cb_mbuf2ring(send_cp, send_up);
-}
-
-void xranLibWraper::Close()
-{
-  if (m_xranhandle)
-    xran_close(m_xranhandle);
-}
-
-int xranLibWraper::Start()
-{
-  if (m_xranhandle)
-    return (xran_start(m_xranhandle));
-  else
-    return (-1);
-}
-
-int xranLibWraper::Stop()
-{
-  if (m_xranhandle)
-    return (xran_stop(m_xranhandle));
-  else
-    return (-1);
-}
-
-/* Emulation of timer */
-void xranLibWraper::update_tti()
-{
-  tti_ota_cb(nullptr, get_timer_ctx());
-}
-
-void xranLibWraper::update_symbol_index()
-{
-  xran_lib_ota_sym_idx++;
-  if ((xran_lib_ota_sym_idx % N_SYM_PER_SLOT) == 0) {
-    update_tti();
-  }
-
-  xran_lib_ota_sym++;
-  if (xran_lib_ota_sym >= N_SYM_PER_SLOT)
-    xran_lib_ota_sym = 0;
-}
-
-int xranLibWraper::apply_cpenable(bool flag)
-{
-  struct xran_device_ctx *pCtx = xran_dev_get_ctx();
-
-  if (is_running())
-    return (-1);
-
-  if (pCtx == nullptr)
-    return (-1);
-
-  if (flag == true) {
-    m_xranInit.enableCP = 1;
-    pCtx->enableCP = 1;
-  } else {
-    m_xranInit.enableCP = 0;
-    pCtx->enableCP = 0;
-  }
-
-  return (0);
-}
-
-int xranLibWraper::get_slot_config(const std::string &cfgname, struct xran_frame_config *pCfg)
-{
-  int numcfg, i;
-  uint32_t j;
-  std::vector<int> slotcfg;
-
-  numcfg = get_globalcfg<int>(cfgname, "period");
-  pCfg->nTddPeriod = numcfg;
-  for (i = 0; i < numcfg; i++) {
-    std::stringstream slotcfgname;
-
-    slotcfgname << "slot" << i;
-    std::vector<int> slotcfg = get_globalcfg_array<int>(cfgname, slotcfgname.str());
-
-    for (j = 0; j < slotcfg.size(); j++)
-      pCfg->sSlotConfig[i].nSymbolType[j] = slotcfg[j];
-    pCfg->sSlotConfig[i].reserved[0] = 0;
-    pCfg->sSlotConfig[i].reserved[1] = 0;
-  }
-
-  return (numcfg);
-}
-
-int xranLibWraper::get_num_rbs(uint32_t nNumerology, uint32_t nBandwidth, bool nSub6)
-{
-  if (nNumerology > 3)
-    return (-1);
-
-  if (nSub6) {
-    if (nNumerology < 3) {
-      /* F1 Tables 38.101-1 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB */
-      switch (nBandwidth) {
-        case PHY_BW_5MHZ:
-          return (nNumRbsPerSymF1[nNumerology][0]);
-        case PHY_BW_10MHZ:
-          return (nNumRbsPerSymF1[nNumerology][1]);
-        case PHY_BW_15MHZ:
-          return (nNumRbsPerSymF1[nNumerology][2]);
-        case PHY_BW_20MHZ:
-          return (nNumRbsPerSymF1[nNumerology][3]);
-        case PHY_BW_25MHZ:
-          return (nNumRbsPerSymF1[nNumerology][4]);
-        case PHY_BW_30MHZ:
-          return (nNumRbsPerSymF1[nNumerology][5]);
-        case PHY_BW_40MHZ:
-          return (nNumRbsPerSymF1[nNumerology][6]);
-        case PHY_BW_50MHZ:
-          return (nNumRbsPerSymF1[nNumerology][7]);
-        case PHY_BW_60MHZ:
-          return (nNumRbsPerSymF1[nNumerology][8]);
-        case PHY_BW_70MHZ:
-          return (nNumRbsPerSymF1[nNumerology][9]);
-        case PHY_BW_80MHZ:
-          return (nNumRbsPerSymF1[nNumerology][10]);
-        case PHY_BW_90MHZ:
-          return (nNumRbsPerSymF1[nNumerology][11]);
-        case PHY_BW_100MHZ:
-          return (nNumRbsPerSymF1[nNumerology][12]);
-      }
-    }
-  } else { /* if(nSub6) */
-    if ((nNumerology >= 2) && (nNumerology <= 3)) {
-      nNumerology -= 2;
-      /* F2 Tables 38.101-2 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB */
-      switch (nBandwidth) {
-        case PHY_BW_50MHZ:
-          return (nNumRbsPerSymF2[nNumerology][0]);
-          break;
-        case PHY_BW_100MHZ:
-          return (nNumRbsPerSymF2[nNumerology][1]);
-          break;
-        case PHY_BW_200MHZ:
-          return (nNumRbsPerSymF2[nNumerology][2]);
-          break;
-        case PHY_BW_400MHZ:
-          return (nNumRbsPerSymF2[nNumerology][3]);
-          break;
-      }
-    }
-  }
-
-  return (-1);
-}
 
 void *xranLibWraper::get_xranhandle()
 {
@@ -1217,17 +147,17 @@ uint32_t xranLibWraper::get_num_antelmtrx()
 
 bool xranLibWraper::is_cpenable()
 {
-  return (m_xranInit.enableCP);
+  return (m_xranConf.enableCP);
 };
 
 bool xranLibWraper::is_prachenable()
 {
-  return (m_xranInit.prachEnable);
+  return (m_xranConf.prachEnable);
 };
 
 bool xranLibWraper::is_dynamicsection()
 {
-  return (m_xranInit.DynamicSectionEna ? true : false);
+  return (m_xranConf.DynamicSectionEna ? true : false);
 }
 
 bool xranLibWraper::get_sub6()
@@ -1258,3 +188,4 @@ void xranLibWraper::get_cfg_fh(struct xran_fh_config *pCfg)
   if (pCfg)
     memcpy(pCfg, &m_xranConf, sizeof(struct xran_fh_config));
 }
+#endif
\ No newline at end of file
diff --git a/radio/ETHERNET/oran/5g/xran_lib_wrap.hpp b/radio/ETHERNET/oran/5g/xran_lib_wrap.hpp
index 1e5c1c9352..e756e63782 100644
--- a/radio/ETHERNET/oran/5g/xran_lib_wrap.hpp
+++ b/radio/ETHERNET/oran/5g/xran_lib_wrap.hpp
@@ -12,262 +12,1380 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <iostream>
 
 #include <malloc.h>
 #include <stdint.h>
 
+#define AAA_OAI
 #include "common.hpp"
 #include "xran_fh_o_du.h"
+#include "xran_fh_o_ru.h"
 #include "xran_common.h"
 #include "xran_frame_struct.h"
 
 #define XRAN_UT_CFG_FILENAME "oran.fhi.json"
 
-#define XRAN_UT_KEY_GLOBALCFG "GLOBAL"
-#define XRAN_UT_KEY_GLOBALCFG_IO "io_cfg"
-#define XRAN_UT_KEY_GLOBALCFG_EAXCID "eAxCId_cfg"
-#define XRAN_UT_KEY_GLOBALCFG_PRACH "prach_cfg"
-#define XRAN_UT_KEY_GLOBALCFG_RU "ru_cfg"
-#define XRAN_UT_KEY_GLOBALCFG_SLOT "slotcfg_"
+#define XRAN_UT_KEY_GLOBALCFG           "GLOBAL"
+#define XRAN_UT_KEY_GLOBALCFG_IO        "io_cfg"
+#define XRAN_UT_KEY_GLOBALCFG_EAXCID    "eAxCId_cfg"
+#define XRAN_UT_KEY_GLOBALCFG_PRACH     "prach_cfg"
+#define XRAN_UT_KEY_GLOBALCFG_RU        "ru_cfg"
+#define XRAN_UT_KEY_GLOBALCFG_SLOT      "slotcfg_"
 
-#define MAX_NUM_OF_XRAN_CTX (2)
+#define MAX_NUM_OF_XRAN_CTX             (2)
 
-#define SW_FPGA_TOTAL_BUFFER_LEN (4 * 1024 * 1024 * 1024)
-#define SW_FPGA_SEGMENT_BUFFER_LEN (1 * 1024 * 1024 * 1024)
-#define SW_FPGA_FH_TOTAL_BUFFER_LEN (1 * 1024 * 1024 * 1024)
-#define FPGA_TO_SW_PRACH_RX_BUFFER_LEN (8192)
+#define SW_FPGA_TOTAL_BUFFER_LEN        (4*1024*1024*1024)
+#define SW_FPGA_SEGMENT_BUFFER_LEN      (1*1024*1024*1024)
+#define SW_FPGA_FH_TOTAL_BUFFER_LEN     (1*1024*1024*1024)
+#define FPGA_TO_SW_PRACH_RX_BUFFER_LEN  (8192)
 
-#define MAX_ANT_CARRIER_SUPPORTED (XRAN_MAX_SECTOR_NR * XRAN_MAX_ANTENNA_NR)
+#define MAX_ANT_CARRIER_SUPPORTED (XRAN_MAX_SECTOR_NR*XRAN_MAX_ANTENNA_NR)
 
-enum xran_in_period { XRAN_IN_PREV_PERIOD = 0, XRAN_IN_CURR_PERIOD, XRAN_IN_NEXT_PERIOD };
-extern "C" {
-extern uint32_t xran_lib_ota_tti;
-extern uint32_t xran_lib_ota_sym;
-extern uint32_t xran_lib_ota_sym_idx;
-extern uint32_t xran_SFN_at_Sec_Start;
+extern "C"
+{
+extern uint32_t xran_lib_ota_tti[];
+extern uint32_t xran_lib_ota_sym[];
+extern uint32_t xran_lib_ota_sym_idx[];
 
 void sym_ota_cb(struct rte_timer *tim, void *arg);
 void tti_ota_cb(struct rte_timer *tim, void *arg);
 }
 
-class xranLibWraper {
- public:
-  typedef enum {
-    XRANFTHTX_OUT = 0,
-    XRANFTHTX_PRB_MAP_OUT,
-    XRANFTHTX_SEC_DESC_OUT,
-    XRANFTHRX_IN,
-    XRANFTHRX_PRB_MAP_IN,
-    XRANFTHTX_SEC_DESC_IN,
-    XRANFTHRACH_IN,
-    XRANSRS_IN,
-    MAX_SW_XRAN_INTERFACE_NUM
-  } SWXRANInterfaceTypeEnum;
-
-  enum nChBw {
-    PHY_BW_5MHZ = 5,
-    PHY_BW_10MHZ = 10,
-    PHY_BW_15MHZ = 15,
-    PHY_BW_20MHZ = 20,
-    PHY_BW_25MHZ = 25,
-    PHY_BW_30MHZ = 30,
-    PHY_BW_40MHZ = 40,
-    PHY_BW_50MHZ = 50,
-    PHY_BW_60MHZ = 60,
-    PHY_BW_70MHZ = 70,
-    PHY_BW_80MHZ = 80,
-    PHY_BW_90MHZ = 90,
-    PHY_BW_100MHZ = 100,
-    PHY_BW_200MHZ = 200,
-    PHY_BW_400MHZ = 400
-  };
-
-  // F1 Tables 38.101-1 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB
-  const uint16_t nNumRbsPerSymF1[3][13] = {
-      //      5MHz   10MHz   15MHz   20MHz   25MHz   30MHz   40MHz   50MHz   60MHz   70MHz   80MHz   90MHz  100MHz
-      {25, 52, 79, 106, 133, 160, 216, 270, 0, 0, 0, 0, 0}, // Numerology 0 (15KHz)
-      {11, 24, 38, 51, 65, 78, 106, 133, 162, 0, 217, 245, 273}, // Numerology 1 (30KHz)
-      {0, 11, 18, 24, 31, 38, 51, 65, 79, 0, 107, 121, 135} // Numerology 2 (60KHz)
-  };
-
-  // F2 Tables 38.101-2 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB
-  const uint16_t nNumRbsPerSymF2[2][4] = {
-      //     50MHz  100MHz  200MHz  400MHz
-      {66, 132, 264, 0}, // Numerology 2 (60KHz)
-      {32, 66, 132, 264} // Numerology 3 (120KHz)
-  };
-
- protected:
-  char argv[25] = {'u', 'n', 'i', 't', 't', 'e', 's', 't', '\0'};
-  // char argv[25] = "unittest";
-
-  std::string m_dpdk_dev_up, m_dpdk_dev_cp, m_dpdk_bbdev;
-
-  void *m_xranhandle;
-
-  uint8_t m_du_mac[6]; // = { 0x00,0x11, 0x22, 0x33, 0x44, 0x55 }; // This is hard coded here and then it is read from the conf file
-  uint8_t m_ru_mac[XRAN_VF_MAX][6]; //= { 0x00,0x11, 0x22, 0x33, 0x44, 0x66 }; // This is hard coded here and then it is read from the conf file
-  bool m_bSub6;
-  uint32_t m_nSlots; // = 20;
 
-  struct xran_fh_config m_xranConf;
-  struct xran_fh_init m_xranInit;
-
-  struct xran_timer_ctx {
-    uint32_t tti_to_process;
-  } m_timer_ctx[MAX_NUM_OF_XRAN_CTX];
-
-  /* io struct */
-  BbuIoBufCtrlStruct m_sFrontHaulTxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  BbuIoBufCtrlStruct m_sFrontHaulTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  BbuIoBufCtrlStruct m_sFrontHaulRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  BbuIoBufCtrlStruct m_sFrontHaulRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  BbuIoBufCtrlStruct m_sFHPrachRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-
-  /* Cat B */
-  BbuIoBufCtrlStruct m_sFHSrsRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
-
-  /* buffers lists */
-  struct xran_flat_buffer m_sFrontHaulTxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
-  struct xran_flat_buffer m_sFrontHaulTxPrbMapBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  struct xran_flat_buffer m_sFrontHaulRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
-  struct xran_flat_buffer m_sFrontHaulRxPrbMapBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
-  struct xran_flat_buffer m_sFHPrachRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
-
-  /* Cat B SRS buffers */
-  struct xran_flat_buffer m_sFHSrsRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_MAX_NUM_OF_SRS_SYMBOL_PER_SLOT];
-
-  void *m_nInstanceHandle[XRAN_PORTS_NUM][XRAN_MAX_SECTOR_NR]; // instance per sector
-  uint32_t m_nBufPoolIndex[XRAN_MAX_SECTOR_NR][MAX_SW_XRAN_INTERFACE_NUM]; // every api owns unique buffer pool
-
-  uint32_t m_nSW_ToFpga_FTH_TxBufferLen;
-  uint32_t m_nFpgaToSW_FTH_RxBufferLen;
-
-  int32_t m_nSectorIndex[XRAN_MAX_SECTOR_NR];
-
-  int iq_bfw_buffer_size_dl = 0;
-  int iq_bfw_buffer_size_ul = 0;
-
-  /* beamforming weights for UL (O-DU) */
-  int16_t *p_tx_dl_bfw_buffer[MAX_ANT_CARRIER_SUPPORTED];
-  int32_t tx_dl_bfw_buffer_size[MAX_ANT_CARRIER_SUPPORTED];
-  int32_t tx_dl_bfw_buffer_position[MAX_ANT_CARRIER_SUPPORTED];
-
-  /* beamforming weights for UL (O-DU) */
-  int16_t *p_tx_ul_bfw_buffer[MAX_ANT_CARRIER_SUPPORTED];
-  int32_t tx_ul_bfw_buffer_size[MAX_ANT_CARRIER_SUPPORTED];
-  int32_t tx_ul_bfw_buffer_position[MAX_ANT_CARRIER_SUPPORTED];
-
- private:
-  json m_global_cfg;
-
-  template <typename T>
-  T get_globalcfg(const std::string &type, const std::string &parameter_name)
-  {
-    return m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name];
-  }
-
-  template <typename T>
-  std::vector<T> get_globalcfg_array(const std::string &type, const std::string &parameter_name)
-  {
-    auto array_size = m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name].size();
-
-    std::vector<T> result(array_size);
-
-    for (unsigned number = 0; number < array_size; number++)
-      result.at(number) = m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name][number];
-
-    return result;
-  }
-
-  uint16_t get_eaxcid_mask(int numbit, int shift);
-
-  int init_memory();
-
- public:
-  // Class constructor
-  xranLibWraper();
-
-  // Class Distructor
-  ~xranLibWraper();
-
-  int SetUp();
-
-  void TearDown();
-
-  int Init(struct xran_fh_config *pCfg = nullptr);
-
-  void Cleanup();
-
-  void Open(xran_ethdi_mbuf_send_fn send_cp, xran_ethdi_mbuf_send_fn send_up, void *fh_rx_callback, void *fh_rx_prach_callback, void *fh_srs_callback);
-
-  void Close();
-
-  int Start();
-
-  int Stop();
-
-  /* emulation of timer */
-  void update_tti();
-
-  void update_symbol_index();
-
-  int apply_cpenable(bool flag);
-
-  int get_slot_config(const std::string &cfgname, struct xran_frame_config *pCfg);
-
-  int get_num_rbs(uint32_t nNumerology, uint32_t nBandwidth, bool nSub6);
-
-  void *get_xranhandle();
-
-  void *get_timer_ctx();
-
-  int get_symbol_index();
-
-  int get_ota_tti();
-
-  int get_SFN_at_sec_start();
-
-  int get_symbol_offset(int32_t offSym, int32_t otaSym, int32_t numSymTotal, enum xran_in_period *pInPeriod);
-
-  bool is_running();
-
-  enum xran_category get_rucategory();
-
-  int get_numerology();
-
-  int get_duplextype();
-
-  uint32_t get_num_cc();
-
-  uint32_t get_num_eaxc();
-
-  uint32_t get_num_eaxc_ul();
-
-  uint32_t get_num_dlrbs();
-
-  uint32_t get_num_ulrbs();
-
-  uint32_t get_num_antelmtrx();
-
-  bool is_cpenable();
-
-  bool is_prachenable();
-
-  bool is_dynamicsection();
-
-  bool get_sub6();
+class xranLibWraper
+{
+public:
+    typedef enum
+    {
+        XRANFTHTX_OUT = 0,
+        XRANFTHTX_PRB_MAP_OUT,
+        XRANFTHTX_SEC_DESC_OUT,
+        XRANFTHRX_IN,
+        XRANFTHRX_PRB_MAP_IN,
+        XRANCP_PRB_MAP_IN_RX,
+        XRANCP_PRB_MAP_IN_TX,
+        XRANFTHTX_SEC_DESC_IN,
+        XRANFTHRACH_IN,
+        MAX_SW_XRAN_INTERFACE_NUM
+    } SWXRANInterfaceTypeEnum;
+
+struct xran_io_buf_ctrl {
+    /* -1-this subframe is not used in current frame format
+         0-this subframe can be transmitted, i.e., data is ready
+          1-this subframe is waiting transmission, i.e., data is not ready
+         10 - DL transmission missing deadline. When FE needs this subframe data but bValid is still 1,
+        set bValid to 10.
+    */
+    int32_t bValid ; // when UL rx, it is subframe index.
+    int32_t nSegToBeGen;
+    int32_t nSegGenerated; // how many date segment are generated by DL LTE processing or received from FE
+                       // -1 means that DL packet to be transmitted is not ready in BS
+    int32_t nSegTransferred; // number of data segments has been transmitted or received
+    //struct rte_mbuf *pData[N_MAX_BUFFER_SEGMENT]; // point to DPDK allocated memory pool
+    struct xran_buffer_list sBufferList;
+};
 
-  void get_cfg_prach(struct xran_prach_config *pCfg);
+struct xran_io_shared_ctrl {
+    /* io struct */
+    struct xran_io_buf_ctrl sFrontHaulTxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFrontHaulTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFrontHaulRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFrontHaulRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFHPrachRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFHPrachRxBbuIoBufCtrlDecomp[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+
+    /* Cat B */
+    struct xran_io_buf_ctrl sFHSrsRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
+    struct xran_io_buf_ctrl sFHSrsRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
+
+    struct xran_io_buf_ctrl sFHCpRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_io_buf_ctrl sFHCpTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+
+    /* buffers lists */
+    struct xran_flat_buffer sFrontHaulTxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
+    struct xran_flat_buffer sFrontHaulTxPrbMapBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_flat_buffer sFrontHaulRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
+    struct xran_flat_buffer sFrontHaulRxPrbMapBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_flat_buffer sFHPrachRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
+    struct xran_flat_buffer sFHPrachRxBuffersDecomp[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
+    
+    struct xran_flat_buffer sFrontHaulCpRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+    struct xran_flat_buffer sFrontHaulCpTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
+
+    /* Cat B SRS buffers */
+    struct xran_flat_buffer sFHSrsRxBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_MAX_NUM_OF_SRS_SYMBOL_PER_SLOT];
+    struct xran_flat_buffer sFHSrsRxPrbMapBuffers[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
+};
 
-  void get_cfg_frame(struct xran_frame_config *pCfg);
+struct bbu_xran_io_if {
+    void*    nInstanceHandle[XRAN_PORTS_NUM][XRAN_MAX_SECTOR_NR]; /* instance per ORAN port */
+    uint32_t nBufPoolIndex[XRAN_PORTS_NUM][XRAN_MAX_SECTOR_NR][MAX_SW_XRAN_INTERFACE_NUM];   /* every api owns unique buffer pool */
+    uint16_t nInstanceNum[XRAN_PORTS_NUM];
+    struct xran_io_shared_ctrl ioCtrl[XRAN_PORTS_NUM]; /**< for each O-RU port */
+};
 
-  void get_cfg_ru(struct xran_ru_config *pCfg);
+    enum nChBw
+    {
+        PHY_BW_5MHZ   =   5, PHY_BW_10MHZ  =  10, PHY_BW_15MHZ  =  15,
+        PHY_BW_20MHZ  =  20, PHY_BW_25MHZ  =  25, PHY_BW_30MHZ  =  30,
+        PHY_BW_40MHZ  =  40, PHY_BW_50MHZ  =  50, PHY_BW_60MHZ  =  60,
+        PHY_BW_70MHZ  =  70, PHY_BW_80MHZ  =  80, PHY_BW_90MHZ  =  90,
+        PHY_BW_100MHZ = 100, PHY_BW_200MHZ = 200, PHY_BW_400MHZ = 400
+    };
+
+    // F1 Tables 38.101-1 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB
+    const uint16_t nNumRbsPerSymF1[3][13] =
+    {
+    //      5MHz   10MHz   15MHz   20MHz   25MHz   30MHz   40MHz   50MHz   60MHz   70MHz   80MHz   90MHz  100MHz
+        {    25,     52,     79,    106,    133,    160,    216,    270,      0,      0,      0,      0,      0 },  // Numerology 0 (15KHz)
+        {    11,     24,     38,     51,     65,     78,    106,    133,    162,      0,    217,    245,    273 },  // Numerology 1 (30KHz)
+        {     0,     11,     18,     24,     31,     38,     51,     65,     79,      0,    107,    121,    135 }   // Numerology 2 (60KHz)
+    };
+
+    // F2 Tables 38.101-2 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB
+    const uint16_t nNumRbsPerSymF2[2][4] =
+    {
+    //     50MHz  100MHz  200MHz  400MHz
+        {    66,    132,    264,      0 },  // Numerology 2 (60KHz)
+        {    32,     66,    132,    264 }   // Numerology 3 (120KHz)
+    };
+
+protected:
+    char argv[25] = "unittest";
+
+    std::string m_dpdk_dev_up, m_dpdk_dev_cp, m_dpdk_bbdev;
+
+    void *m_xranhandle;
+
+    uint8_t m_du_mac[6] = { 0x00,0x11, 0x22, 0x33, 0x44, 0x66 };
+    uint8_t m_ru_mac[6] = { 0x00,0x11, 0x22, 0x33, 0x44, 0x55 };
+    bool m_bSub6;
+    uint32_t m_nSlots = 10;
+
+    struct xran_fh_config   m_xranConf;
+    struct xran_fh_init     m_xranInit;
+
+    struct xran_timer_ctx {
+        uint32_t    tti_to_process;
+        } m_timer_ctx[MAX_NUM_OF_XRAN_CTX];
+
+    struct bbu_xran_io_if  m_gsXranIoIf;
+
+    uint32_t m_nSW_ToFpga_FTH_TxBufferLen;
+    uint32_t m_nFpgaToSW_FTH_RxBufferLen;
+
+    int32_t m_nSectorIndex[XRAN_MAX_SECTOR_NR];
+
+    int iq_bfw_buffer_size_dl = 0;
+    int iq_bfw_buffer_size_ul = 0;
+
+    /* beamforming weights for UL (O-DU) */
+    int16_t *p_tx_dl_bfw_buffer[MAX_ANT_CARRIER_SUPPORTED];
+    int32_t tx_dl_bfw_buffer_size[MAX_ANT_CARRIER_SUPPORTED];
+    int32_t tx_dl_bfw_buffer_position[MAX_ANT_CARRIER_SUPPORTED];
+
+    /* beamforming weights for UL (O-DU) */
+    int16_t *p_tx_ul_bfw_buffer[MAX_ANT_CARRIER_SUPPORTED];
+    int32_t tx_ul_bfw_buffer_size[MAX_ANT_CARRIER_SUPPORTED];
+    int32_t tx_ul_bfw_buffer_position[MAX_ANT_CARRIER_SUPPORTED];
+
+private:
+    json m_global_cfg;
+
+    template<typename T>
+    T get_globalcfg(const std::string &type, const std::string &parameter_name)
+    {
+        return m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name];
+    }
+
+    template<typename T>
+    std::vector<T> get_globalcfg_array(const std::string &type, const std::string &parameter_name)
+    {
+        auto array_size = m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name].size();
+
+        std::vector<T> result(array_size);
+
+        for(unsigned number = 0; number < array_size; number++)
+            result.at(number) = m_global_cfg[XRAN_UT_KEY_GLOBALCFG][type][parameter_name][number];
+
+        return result;
+    }
+
+    uint16_t get_eaxcid_mask(int numbit, int shift)
+    {
+        uint16_t result = 0;
+
+        for(int i=0; i < numbit; i++) {
+            result = result << 1; result +=1;
+            }
+        return (result << shift);
+    }
+
+    int init_memory(uint32_t o_xu_id)
+    {
+        xran_status_t status;
+        uint32_t i, j, k, z, m;
+        SWXRANInterfaceTypeEnum eInterfaceType;
+        void *ptr;
+        void *mb;
+        uint32_t *u32dptr;
+        uint16_t *u16dptr;
+        uint8_t  *u8dptr;
+
+        struct bbu_xran_io_if *psBbuIo = (struct bbu_xran_io_if*)&m_gsXranIoIf;
+        struct xran_io_shared_ctrl *psIoCtrl =  (struct xran_io_shared_ctrl *)&psBbuIo->ioCtrl[o_xu_id];
+
+        uint32_t xran_max_antenna_nr = (uint32_t)RTE_MAX((uint32_t)get_num_eaxc(), (uint32_t)get_num_eaxc_ul());
+        uint32_t xran_max_ant_array_elm_nr = (uint32_t)RTE_MAX((uint32_t)get_num_antelmtrx(), (uint32_t)xran_max_antenna_nr);
+
+
+        std::cout << "XRAN front haul xran_mm_init" << std::endl;
+        status = xran_mm_init(m_xranhandle, (uint64_t) SW_FPGA_FH_TOTAL_BUFFER_LEN, SW_FPGA_SEGMENT_BUFFER_LEN);
+        if(status != XRAN_STATUS_SUCCESS) {
+            std::cout << "Failed at XRAN front haul xran_mm_init" << std::endl;
+            return (-1);
+            }
+
+        /* initialize maximum instances to have flexibility for the tests */
+
+        /* initialize maximum supported CC to have flexibility on the test */
+        uint32_t nSectorNum = 6;//XRAN_MAX_SECTOR_NR;
+
+        k = o_xu_id;
+        psBbuIo->nInstanceNum[k] = nSectorNum;
+        status = xran_sector_get_instances(k, m_xranhandle, psBbuIo->nInstanceNum[k], &psBbuIo->nInstanceHandle[k][0]);
+            if(status != XRAN_STATUS_SUCCESS) {
+            std::cout  << "get sector instance failed " << k << " for XRAN nInstanceNum " << psBbuIo->nInstanceNum[k] << std::endl;
+                return (-1);
+                }
+        for (i = 0; i < psBbuIo->nInstanceNum[k]; i++)
+            std::cout << __func__ << " [" << k << "]: CC " << i << " handle " << psBbuIo->nInstanceHandle[k][i] << std::endl;
+
+        std::cout << "Sucess xran_mm_init" << std::endl;
+
+        /* Init Memory */
+        for(i = 0; i<nSectorNum; i++) {
+            eInterfaceType = XRANFTHTX_OUT;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                            &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                            XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                            m_nSW_ToFpga_FTH_TxBufferLen);
+            if(status != XRAN_STATUS_SUCCESS) {
+                std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
+                return (-1);
+                }
+            for(j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++){
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].bValid = 0;
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &psIoCtrl->sFrontHaulTxBuffers[j][i][z][0];
+
+                    for(k = 0; k < XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
+                        psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes = m_nSW_ToFpga_FTH_TxBufferLen; // 14 symbols 3200bytes/symbol
+                        psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements = 1;
+                        psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes = 0;
+                        status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i], psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
+                        if(status != XRAN_STATUS_SUCCESS) {
+                            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
+                            return (-1);
+                            }
+                        psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
+                        psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
+
+                        if(ptr) {
+                            u32dptr = (uint32_t*)(ptr);
+                            uint8_t *ptr_temp = (uint8_t *)ptr;
+                            memset(u32dptr, 0x0, m_nSW_ToFpga_FTH_TxBufferLen);
+                            }
+                        }
+                    }
+                }
+
+            /* C-plane DL */
+            eInterfaceType = XRANFTHTX_PRB_MAP_OUT;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                            &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                            XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                            sizeof(struct xran_prb_map));
+            if(status != XRAN_STATUS_SUCCESS) {
+                std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
+                return (-1);
+            }
+            for(j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++) {
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].bValid = 0;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &psIoCtrl->sFrontHaulTxPrbMapBuffers[j][i][z];
+
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes = sizeof(struct xran_prb_map);
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements = 1;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes = 0;
+
+                    status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i], psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
+                    if(status != XRAN_STATUS_SUCCESS) {
+                        std::cout << __LINE__ << " Failed at xran_bm_allocate_buffer, status " << status << std::endl;
+                        return (-1);
+                        }
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData = (uint8_t *)ptr;
+                    psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl = (void *)mb;
+
+                    struct xran_prb_map * p_rb_map = (struct xran_prb_map *)ptr;
+                    //memcpy(ptr, &startupConfiguration.PrbMap, sizeof(struct xran_prb_map));
+                }
+             }
+            /* C-plane */
+            eInterfaceType = XRANCP_PRB_MAP_IN_RX;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                            &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                            XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                            sizeof(struct xran_prb_map));
+                            if(XRAN_STATUS_SUCCESS != status){
+                rte_panic("Failed at xran_bm_init, status %d\n", status);
+                            }
+
+            for(j = 0;j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++){
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].bValid = 0;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &psIoCtrl->sFrontHaulCpRxPrbMapBbuIoBufCtrl[j][i][z];
+
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes = sizeof(struct xran_prb_map);
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements = 1;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes = 0;
+                    status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i], psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
+                    if(XRAN_STATUS_SUCCESS != status) {
+                        rte_panic("Failed at  xran_bm_allocate_buffer , status %d\n",status);
+                            }
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData = (uint8_t *)ptr;
+                    psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl = (void *)mb;
+                    struct xran_prb_map * p_rb_map = (struct xran_prb_map *)ptr;
+                        }
+                    }
+
+
+            /* C-plane Tx */
+            eInterfaceType = XRANCP_PRB_MAP_IN_TX;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                            &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                            XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                            sizeof(struct xran_prb_map));
+            if(XRAN_STATUS_SUCCESS != status) {
+                rte_panic("Failed at xran_bm_init, status %d\n", status);
+            }
+
+            for(j = 0;j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++){
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].bValid = 0;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated = -1;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen = -1;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred = 0;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers = &psIoCtrl->sFrontHaulCpTxPrbMapBbuIoBufCtrl[j][i][z];
+
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes = sizeof(struct xran_prb_map);
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements = 1;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes = 0;
+                    status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i],psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],&ptr, &mb);
+                    if(XRAN_STATUS_SUCCESS != status) {
+                        rte_panic("Failed at  xran_bm_allocate_buffer , status %d\n",status);
+                    }
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData = (uint8_t *)ptr;
+                    psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl = (void *)mb;
+                    struct xran_prb_map * p_rb_map = (struct xran_prb_map *)ptr;
+                 }
+             }
+        }
+
+        for(i = 0; i<nSectorNum; i++) {
+            eInterfaceType = XRANFTHRX_IN;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                            &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                            XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                            m_nSW_ToFpga_FTH_TxBufferLen);  /* ????, actual alloc size is m_nFpgaToSW_FTH_RxBUfferLen */
+            if(status != XRAN_STATUS_SUCCESS) {
+                std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
+                return (-1);
+                }
+
+            for(j = 0;j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++) {
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].bValid                  = 0;
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegGenerated           = -1;
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegToBeGen             = -1;
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].nSegTransferred         = 0;
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers    = &psIoCtrl->sFrontHaulRxBuffers[j][i][z][0];
+                    for(k = 0; k< XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
+                        psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes  = m_nFpgaToSW_FTH_RxBufferLen;
+                        psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements   = 1;
+                        psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes      = 0;
+                        status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i], psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],&ptr, &mb);
+                        if(status != XRAN_STATUS_SUCCESS) {
+                            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
+                            return (-1);
+                            }
+                        psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData   = (uint8_t *)ptr;
+                        psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl   = (void *) mb;
+                        if(ptr) {
+                            u32dptr = (uint32_t*)(ptr);
+                            uint8_t *ptr_temp = (uint8_t *)ptr;
+                            memset(u32dptr, 0x0, m_nFpgaToSW_FTH_RxBufferLen);
+                            }
+                        }
+                    }
+                }
+
+            eInterfaceType = XRANFTHRX_PRB_MAP_IN;
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                                &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                                XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                                sizeof(struct xran_prb_map));
+            if(status != XRAN_STATUS_SUCCESS) {
+                std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
+                return (-1);
+            }
+
+            for(j = 0;j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++) {
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].bValid                    = 0;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegGenerated             = -1;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegToBeGen               = -1;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].nSegTransferred           = 0;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers   = XRAN_NUM_OF_SYMBOL_PER_SLOT;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers      = &psIoCtrl->sFrontHaulRxPrbMapBuffers[j][i][z];
+
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nElementLenInBytes  = sizeof(struct xran_prb_map);
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nNumberOfElements   = 1;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->nOffsetInBytes      = 0;
+                    status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i],psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
+                    if(status != XRAN_STATUS_SUCCESS) {
+                        std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer , status " << status << std::endl;
+                        return (-1);
+                        }
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pData   = (uint8_t *)ptr;
+                    psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList.pBuffers->pCtrl   = (void *)mb;
+                    struct xran_prb_map * p_rb_map = (struct xran_prb_map *)ptr;
+                    //memcpy(ptr, &startupConfiguration.PrbMap, sizeof(struct xran_prb_map));
+                }
+            }
+        }
+
+        for(i = 0; i<nSectorNum; i++) {
+            eInterfaceType = XRANFTHRACH_IN;
+
+            status = xran_bm_init(psBbuIo->nInstanceHandle[o_xu_id][i],
+                                &psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType],
+                                XRAN_N_FE_BUF_LEN * xran_max_antenna_nr * XRAN_NUM_OF_SYMBOL_PER_SLOT,
+                                PRACH_PLAYBACK_BUFFER_BYTES);
+            if(status != XRAN_STATUS_SUCCESS) {
+                std::cout << __LINE__ << " Failed at xran_bm_init, status " << status << std::endl;
+                return (-1);
+                }
+            for(j = 0; j < XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < xran_max_antenna_nr; z++) {
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].bValid                    = 0;
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].nSegGenerated             = -1;
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].nSegToBeGen               = -1;
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].nSegTransferred           = 0;
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.nNumBuffers   = xran_max_antenna_nr;
+                    psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers      = &psIoCtrl->sFHPrachRxBuffers[j][i][z][0];
+                    for(k = 0; k< XRAN_NUM_OF_SYMBOL_PER_SLOT; k++) {
+                        psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nElementLenInBytes    = PRACH_PLAYBACK_BUFFER_BYTES;
+                        psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nNumberOfElements     = 1;
+                        psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].nOffsetInBytes        = 0;
+                        status = xran_bm_allocate_buffer(psBbuIo->nInstanceHandle[o_xu_id][i], psBbuIo->nBufPoolIndex[o_xu_id][m_nSectorIndex[i]][eInterfaceType], &ptr, &mb);
+                        if(status != XRAN_STATUS_SUCCESS) {
+                            std::cout << __LINE__ << " Failed at  xran_bm_allocate_buffer, status " << status << std::endl;
+                            return (-1);
+                            }
+                        psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pData = (uint8_t *)ptr;
+                        psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList.pBuffers[k].pCtrl = (void *)mb;
+                        if(ptr) {
+                            u32dptr = (uint32_t*)(ptr);
+                            memset(u32dptr, 0x0, PRACH_PLAYBACK_BUFFER_BYTES);
+                            }
+                        }
+                    }
+                }
+            }
+
+        return (0);
+    }
+
+
+public:
+    xranLibWraper()
+    {
+        int i, temp;
+        std::string tmpstr;
+        unsigned int tmp_mac[6];
+
+        m_global_cfg = read_json_from_file(XRAN_UT_CFG_FILENAME);
+
+        memset(&m_xranInit, 0, sizeof(xran_fh_init));
+
+        m_xranInit.io_cfg.id  = 0;
+
+        /* DPDK configuration */
+        m_dpdk_dev_up = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdk_dev_up");
+        m_dpdk_dev_cp = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdk_dev_cp");
+        m_xranInit.io_cfg.nEthLineSpeed    = 10;
+        m_xranInit.io_cfg.num_vfs = 2;
+        m_xranInit.io_cfg.dpdk_dev[XRAN_UP_VF]  = (m_dpdk_dev_up == "") ? NULL : (char *)&m_dpdk_dev_up[0];
+        m_xranInit.io_cfg.dpdk_dev[XRAN_CP_VF]  = (m_dpdk_dev_cp == "") ? NULL : (char *)&m_dpdk_dev_cp[0];
+
+        m_xranInit.io_cfg.core              = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "core");
+        m_xranInit.io_cfg.system_core       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "system_core");
+        m_xranInit.io_cfg.pkt_proc_core     = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "pkt_proc_core");
+        m_xranInit.io_cfg.pkt_aux_core      = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "pkt_aux_core");
+        m_xranInit.io_cfg.timing_core       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "timing_core");
+        m_xranInit.io_cfg.dpdkMemorySize    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdkMemorySize");
+
+        m_xranInit.xran_ports = 1;
+
+        std::string bbdev_mode = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "bbdev_mode");
+        if(bbdev_mode == "sw")
+            m_xranInit.io_cfg.bbdev_mode    = XRAN_BBDEV_MODE_HW_OFF;
+        else if(bbdev_mode == "hw")
+            m_xranInit.io_cfg.bbdev_mode    = XRAN_BBDEV_MODE_HW_ON;
+        else if(bbdev_mode == "none")
+            m_xranInit.io_cfg.bbdev_mode    = XRAN_BBDEV_NOT_USED;
+        else {
+            std::cout << "Invalid BBDev mode [" << bbdev_mode << "], bbdev won't be used." << std::endl;
+            m_xranInit.io_cfg.bbdev_mode    = XRAN_BBDEV_NOT_USED;
+            }
+
+        m_xranInit.dpdkBasebandFecMode      = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdkBasebandFecMode");
+
+
+        m_dpdk_bbdev = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "dpdkBasebandDevice");
+        m_xranInit.dpdkBasebandDevice       = (m_dpdk_bbdev == "") ? NULL : (char *)&m_dpdk_bbdev;
+
+        /* Network configurations */
+        m_xranInit.mtu          = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "mtu");
+
+        std::string du_mac_str = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "o_du_macaddr");
+        std::string ru_mac_str = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_IO, "o_ru_macaddr");
+        /* using temp variables to resolve KW issue */
+        std::sscanf(du_mac_str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x",
+                                           &tmp_mac[0], &tmp_mac[1], &tmp_mac[2],
+                                           &tmp_mac[3], &tmp_mac[4], &tmp_mac[5]);
+        for(i=0; i<6; i++)
+            m_du_mac[i] = (uint8_t)tmp_mac[i];
+        std::sscanf(du_mac_str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x",
+                                           &tmp_mac[0], &tmp_mac[1], &tmp_mac[2],
+                                           &tmp_mac[3], &tmp_mac[4], &tmp_mac[5]);
+        for(i=0; i<6; i++)
+            m_ru_mac[i] = (uint8_t)tmp_mac[i];
+        m_xranInit.p_o_du_addr  = (int8_t *)m_du_mac;
+        m_xranInit.p_o_ru_addr  = (int8_t *)m_ru_mac;
+        m_xranConf.cp_vlan_tag  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "cp_vlan_tag");
+        m_xranConf.up_vlan_tag  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_IO, "up_vlan_tag");
+
+        /* eAxCID configurations */
+        int bitnum_cuport   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_cuPortId");
+        int bitnum_bandsec  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_bandSectorId");
+        int bitnum_ccid     = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_ccId");
+        int bitnum_ruport   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_EAXCID, "bit_ruPortId");
+
+        m_xranInit.eAxCId_conf.bit_cuPortId       = bitnum_bandsec + bitnum_ccid + bitnum_ruport;
+        m_xranInit.eAxCId_conf.bit_bandSectorId   = bitnum_ccid + bitnum_ruport;
+        m_xranInit.eAxCId_conf.bit_ccId           = bitnum_ruport;
+        m_xranInit.eAxCId_conf.bit_ruPortId       = 0;
+        m_xranInit.eAxCId_conf.mask_cuPortId      = get_eaxcid_mask(bitnum_cuport, m_xranInit.eAxCId_conf.bit_cuPortId);
+        m_xranInit.eAxCId_conf.mask_bandSectorId  = get_eaxcid_mask(bitnum_bandsec, m_xranInit.eAxCId_conf.bit_bandSectorId);
+        m_xranInit.eAxCId_conf.mask_ccId          = get_eaxcid_mask(bitnum_ccid, m_xranInit.eAxCId_conf.bit_ccId);
+        m_xranInit.eAxCId_conf.mask_ruPortId      = get_eaxcid_mask(bitnum_ruport, m_xranInit.eAxCId_conf.bit_ruPortId);
+
+        m_xranInit.totalBfWeights   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "totalBfWeights");
+        m_xranInit.filePrefix   = (char *)"wls";
+
+        m_bSub6     = get_globalcfg<bool>(XRAN_UT_KEY_GLOBALCFG_RU, "sub6");
+
+        memset(&m_xranConf, 0, sizeof(struct xran_fh_config));
+
+        // m_xranConf.log_level = get_globalcfg<uint32_t>(XRAN_UT_KEY_GLOBALCFG_RU, "loglevel");
+        m_xranConf.log_level = 1;
+        m_xranConf.Tadv_cp_dl       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Tadv_cp_dl");
+        m_xranConf.T2a_min_cp_dl    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_cp_dl");
+        m_xranConf.T2a_max_cp_dl    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_cp_dl");
+        m_xranConf.T2a_min_cp_ul    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_cp_ul");
+        m_xranConf.T2a_max_cp_ul    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_cp_ul");
+        m_xranConf.T2a_min_up       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_min_up");
+        m_xranConf.T2a_max_up       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T2a_max_up");
+        m_xranConf.Ta3_min          = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta3_min");
+        m_xranConf.Ta3_max          = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta3_max");
+        m_xranConf.T1a_min_cp_dl    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_cp_dl");
+        m_xranConf.T1a_max_cp_dl    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_cp_dl");
+        m_xranConf.T1a_min_cp_ul    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_cp_ul");
+        m_xranConf.T1a_max_cp_ul    = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_cp_ul");
+        m_xranConf.T1a_min_up       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_min_up");
+        m_xranConf.T1a_max_up       = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "T1a_max_up");
+        m_xranConf.Ta4_min          = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta4_min");
+        m_xranConf.Ta4_max          = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "Ta4_max");
+
+        m_xranConf.enableCP         = 1;
+        m_xranConf.prachEnable      = 1;
+        m_xranConf.debugStop        = 0;
+        m_xranConf.debugStopCount   = 0;
+        m_xranConf.DynamicSectionEna= 0;
+
+        tmpstr = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "duplex");
+        if(tmpstr == "FDD") {
+            m_xranConf.frame_conf.nFrameDuplexType  = 0;
+            }
+        else if(tmpstr == "TDD") {
+            m_xranConf.frame_conf.nFrameDuplexType  = 1;
+
+            std::string slotcfg_key = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "slot_config");
+
+            int numcfg = get_globalcfg<int>(slotcfg_key, "period");
+            m_xranConf.frame_conf.nTddPeriod = numcfg;
+
+            for(int i=0; i< numcfg; i++) {
+                std::stringstream slotcfgname;
+                slotcfgname << "slot" << i;
+                std::vector<int> slotcfg = get_globalcfg_array<int>(slotcfg_key, slotcfgname.str());
+                for(int j=0; j < (int)slotcfg.size(); j++) {
+                    m_xranConf.frame_conf.sSlotConfig[i].nSymbolType[j] = slotcfg[j];
+                    }
+                m_xranConf.frame_conf.sSlotConfig[i].reserved[0] = 0;
+                m_xranConf.frame_conf.sSlotConfig[i].reserved[1] = 0;
+                }
+            }
+        else {
+            std::cout << "*** Invalid Duplex type [" << tmpstr << "] !!!" << std::endl;
+            std::cout << "****** Set it to FDD... " << std::endl;
+            m_xranConf.frame_conf.nFrameDuplexType  = 0;
+            }
+
+        m_xranConf.frame_conf.nNumerology = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "mu");
+        if(m_xranConf.frame_conf.nNumerology > 3) {
+            std::cout << "*** Invalid Numerology [" << m_xranConf.frame_conf.nNumerology << "] !!!" << std::endl;
+            m_xranConf.frame_conf.nNumerology   = 0;
+            std::cout << "****** Set it to " << m_xranConf.frame_conf.nNumerology << "..." << std::endl;
+            }
+
+        m_xranConf.nCC = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "num_cc");
+        if(m_xranConf.nCC > XRAN_MAX_SECTOR_NR) {
+            std::cout << "*** Exceeds maximum number of carriers supported [" << m_xranConf.nCC << "] !!!" << std::endl;
+            m_xranConf.nCC = XRAN_MAX_SECTOR_NR;
+            std::cout << "****** Adjusted to " << m_xranConf.nCC << "..." << std::endl;
+            }
+        m_xranConf.neAxc = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "num_eaxc");
+        if(m_xranConf.neAxc > XRAN_MAX_ANTENNA_NR) {
+            std::cout << "*** Exceeds maximum number of antenna supported [" << m_xranConf.neAxc << "] !!!" << std::endl;
+            m_xranConf.neAxc = XRAN_MAX_ANTENNA_NR;
+            std::cout << "****** Adjusted to " << m_xranConf.neAxc << "..." << std::endl;
+            }
+
+        m_bSub6     = get_globalcfg<bool>(XRAN_UT_KEY_GLOBALCFG_RU, "sub6");
+        temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "chbw_dl");
+        m_xranConf.nDLRBs = get_num_rbs(get_numerology(), temp, m_bSub6);
+        temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "chbw_ul");
+        m_xranConf.nULRBs = get_num_rbs(get_numerology(), temp, m_bSub6);
+        m_xranConf.dpdk_port    = 0;
+
+        m_xranConf.nAntElmTRx = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "ant_elm_trx");
+        m_xranConf.nDLFftSize = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
+        m_xranConf.nULFftSize = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
+
+        m_xranConf.prach_conf.nPrachConfIdx     = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "config_id");
+        m_xranConf.prach_conf.nPrachSubcSpacing = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "scs");
+        m_xranConf.prach_conf.nPrachFreqStart   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "freq_start");
+        m_xranConf.prach_conf.nPrachFreqOffset  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "freq_offset");
+        m_xranConf.prach_conf.nPrachFilterIdx   = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_PRACH, "filter_id");
+        m_xranConf.prach_conf.nPrachZeroCorrConf= 0;
+        m_xranConf.prach_conf.nPrachRestrictSet = 0;
+        m_xranConf.prach_conf.nPrachRootSeqIdx  = 0;
+
+        tmpstr = get_globalcfg<std::string>(XRAN_UT_KEY_GLOBALCFG_RU, "category");
+        if(tmpstr == "A")
+            m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_A;
+        else if(tmpstr == "B")
+            m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_B;
+        else {
+            std::cout << "*** Invalid RU Category [" << tmpstr << "] !!!" << std::endl;
+            std::cout << "****** Set it to Category A... " << std::endl;
+            m_xranConf.ru_conf.xranCat = XRAN_CATEGORY_A;
+            }
+
+        m_xranConf.ru_conf.iqWidth  = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "iq_width");
+        m_xranConf.ru_conf.compMeth = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "comp_meth");
+
+        temp = get_globalcfg<int>(XRAN_UT_KEY_GLOBALCFG_RU, "fft_size");
+        m_xranConf.ru_conf.fftSize  = 0;
+        while (temp >>= 1)
+            ++m_xranConf.ru_conf.fftSize;
+
+        m_xranConf.ru_conf.byteOrder    =  XRAN_NE_BE_BYTE_ORDER;
+        m_xranConf.ru_conf.iqOrder      =  XRAN_I_Q_ORDER;
+
+        m_xranConf.log_level    = 0;
+/*
+        m_xranConf.bbdev_enc = nullptr;
+        m_xranConf.bbdev_dec = nullptr;
+        m_xranConf.ttiCb    = nullptr;
+        m_xranConf.ttiCbParam   = nullptr;
+*/
+    }
+
+    ~xranLibWraper()
+    {
+    }
+
+    int SetUp()
+    {
+        int i;
+
+        printf("O-DU MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+            m_xranInit.p_o_du_addr[0],
+            m_xranInit.p_o_du_addr[1],
+            m_xranInit.p_o_du_addr[2],
+            m_xranInit.p_o_du_addr[3],
+            m_xranInit.p_o_du_addr[4],
+            m_xranInit.p_o_du_addr[5]);
+
+        printf("O-RU MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+            m_xranInit.p_o_ru_addr[0],
+            m_xranInit.p_o_ru_addr[1],
+            m_xranInit.p_o_ru_addr[2],
+            m_xranInit.p_o_ru_addr[3],
+            m_xranInit.p_o_ru_addr[4],
+            m_xranInit.p_o_ru_addr[5]);
+
+        printf("eAxCID - %d:%d:%d:%d (%04x, %04x, %04x, %04x)\n",
+            m_xranInit.eAxCId_conf.bit_cuPortId,
+            m_xranInit.eAxCId_conf.bit_bandSectorId,
+            m_xranInit.eAxCId_conf.bit_ccId,
+            m_xranInit.eAxCId_conf.bit_ruPortId,
+            m_xranInit.eAxCId_conf.mask_cuPortId,
+            m_xranInit.eAxCId_conf.mask_bandSectorId,
+            m_xranInit.eAxCId_conf.mask_ccId,
+            m_xranInit.eAxCId_conf.mask_ruPortId);
+
+        printf("Total BF Weights : %d\n", m_xranInit.totalBfWeights);
+
+        xran_init(0, NULL, &m_xranInit, &argv[0], &m_xranhandle);
+
+
+
+        for(i = 0; i < XRAN_MAX_SECTOR_NR; i++)
+            m_nSectorIndex[i] = i;
+
+        /* set to maximum length to support multiple cases */
+        m_nFpgaToSW_FTH_RxBufferLen     = 13168; /* 273*12*4 + 64*/
+        m_nSW_ToFpga_FTH_TxBufferLen    = 13168; /* 273*12*4 + 64*/
+
+        if(init_memory(0) < 0) {
+            std::cout << "Fatal Error on Initialization !!!" << std::endl;
+            std::cout << "INIT FAILED" << std::endl;
+            return (-1);
+            }
+
+        std::cout << "INIT DONE" << std::endl;
+        return (0);
+    }
+
+    void TearDown()
+    {
+        if(m_xranhandle) {
+            xran_close(m_xranhandle);
+            m_xranhandle = nullptr;
+            std::cout << "CLOSE DONE" << std::endl;
+            }
+        else
+            std::cout << "ALREADY CLOSED" << std::endl;
+    }
+
+    int Init(uint32_t o_xu_id, struct xran_fh_config *pCfg = nullptr)
+    {
+        xran_status_t status;
+        uint32_t nSectorNum;
+        int32_t i, j, k, z;
+        void *ptr;
+        void *mb;
+        uint32_t *u32dptr;
+        uint16_t *u16dptr;
+        uint8_t  *u8dptr;
+        SWXRANInterfaceTypeEnum eInterfaceType;
+        uint32_t cc_id, ant_id, sym_id, tti;
+        int32_t flowId;
+        char    *pos        = NULL;
+        struct xran_prb_map *pRbMap = NULL;
+        struct xran_prb_map tmppRbMap;
+
+        struct bbu_xran_io_if *psBbuIo = (struct bbu_xran_io_if*)&m_gsXranIoIf;
+        struct xran_io_shared_ctrl *psIoCtrl =  (struct xran_io_shared_ctrl *)&psBbuIo->ioCtrl[o_xu_id];
+
+        uint32_t xran_max_antenna_nr = RTE_MAX(get_num_eaxc(), get_num_eaxc_ul());
+        uint32_t xran_max_ant_array_elm_nr = RTE_MAX(get_num_antelmtrx(), xran_max_antenna_nr);
+
+
+        /* Update member variables */
+        if(pCfg)
+            memcpy(&m_xranConf, pCfg, sizeof(struct xran_fh_config));
+
+        /* Init timer context */
+        for (i=0; i<XRAN_PORTS_NUM; i++)
+        {
+            xran_lib_ota_sym[i] = 0;
+            xran_lib_ota_sym_idx[i] = 0;
+            xran_lib_ota_tti[i]        = 0;
+        }
+        for(i=0; i < MAX_NUM_OF_XRAN_CTX; i++)
+            m_timer_ctx[i].tti_to_process = i;
+
+        nSectorNum = get_num_cc();
+
+        /* Cat B RU support */
+        if(get_rucategory() == XRAN_CATEGORY_B) {
+            /* 10 * [14*32*273*2*2] = 4892160 bytes */
+            iq_bfw_buffer_size_dl = (m_nSlots * N_SYM_PER_SLOT * get_num_antelmtrx() * get_num_dlrbs() * 4L);
+            iq_bfw_buffer_size_ul = (m_nSlots * N_SYM_PER_SLOT * get_num_antelmtrx() * get_num_ulrbs() * 4L);
+
+            for(i = 0; i < MAX_ANT_CARRIER_SUPPORTED && i < (get_num_cc() * get_num_eaxc()); i++) {
+                p_tx_dl_bfw_buffer[i]   = (int16_t*)malloc(iq_bfw_buffer_size_dl);
+                tx_dl_bfw_buffer_size[i] = (int32_t)iq_bfw_buffer_size_dl;
+                if(p_tx_dl_bfw_buffer[i] == NULL)
+                    return(-1);
+
+                memset(p_tx_dl_bfw_buffer[i], 'D', iq_bfw_buffer_size_dl);
+                tx_dl_bfw_buffer_position[i] = 0;
+
+                p_tx_ul_bfw_buffer[i]    = (int16_t*)malloc(iq_bfw_buffer_size_ul);
+                tx_ul_bfw_buffer_size[i] = (int32_t)iq_bfw_buffer_size_ul;
+                if(p_tx_ul_bfw_buffer[i] == NULL)
+                    return (-1);
+
+                memset(p_tx_ul_bfw_buffer[i], 'U', iq_bfw_buffer_size_ul);
+                tx_ul_bfw_buffer_position[i] = 0;
+            }
+        }
+
+        /* Init RB map */
+        for(cc_id = 0; cc_id <nSectorNum; cc_id++) {
+            for(tti  = 0; tti  < XRAN_N_FE_BUF_LEN; tti ++) {
+                for(ant_id = 0; ant_id < xran_max_antenna_nr; ant_id++) {
+                    flowId = xran_max_antenna_nr*cc_id + ant_id;
+
+                    /* C-plane DL */
+                    pRbMap = (struct xran_prb_map *)psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
+                    if(pRbMap) {
+                        pRbMap->dir                     = XRAN_DIR_DL;
+                        pRbMap->xran_port               = 0;
+                        pRbMap->band_id                 = 0;
+                        pRbMap->cc_id                   = cc_id;
+                        pRbMap->ru_port_id              = ant_id;
+                        pRbMap->tti_id                  = tti;
+                        pRbMap->start_sym_id            = 0;
+
+                        pRbMap->nPrbElm                 = 1;
+                        pRbMap->prbMap[0].nRBStart      = 0;
+                        pRbMap->prbMap[0].nRBSize       = get_num_dlrbs();
+                        pRbMap->prbMap[0].nStartSymb    = 0;
+                        pRbMap->prbMap[0].numSymb       = 14;
+                        pRbMap->prbMap[0].nBeamIndex    = 0;
+                        pRbMap->prbMap[0].compMethod    = XRAN_COMPMETHOD_NONE;
+
+                        if(get_rucategory() == XRAN_CATEGORY_A) {
+                            pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_ID_BASED;
+                            pRbMap->prbMap[0].bf_weight_update  = 0;
+                            //pRbMap->prbMap[0].bf_attribute.weight[];
+                            //pRbMap->prbMap[0].bf_precoding.weight[];
+                            }
+                        else if(get_rucategory() == XRAN_CATEGORY_B) {
+                            int idxElm;
+                            int iPrb;
+                            char *dl_bfw_pos = ((char*)p_tx_dl_bfw_buffer[flowId]) + tx_dl_bfw_buffer_position[flowId];
+                            struct xran_prb_elm* p_prbMap = NULL;
+                            // int num_antelm;
+
+                            pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_WEIGHT;
+                            pRbMap->prbMap[0].bf_weight_update  = 1;
+
+                            // num_antelm = get_num_antelmtrx();
+#if 0
+                            /* populate beam weights to C-plane for each elm */
+                            pRbMap->bf_weight.nAntElmTRx = num_antelm;
+                            for(idxElm = 0;  idxElm < pRbMap->nPrbElm; idxElm++){
+                                p_prbMap = &pRbMap->prbMap[idxElm];
+                                for (iPrb = p_prbMap->nRBStart; iPrb < (p_prbMap->nRBStart + p_prbMap->nRBSize); iPrb++) {
+                                    /* copy BF W IQs for 1 PRB of */
+                                    memcpy(&pRbMap->bf_weight.weight[iPrb][0], (dl_bfw_pos + (iPrb * num_antelm)*4), num_antelm*4);
+                                    }
+                                }
+#endif
+                            } /* else if(get_rucategory() == XRAN_CATEGORY_B) */
+                        memcpy(&tmppRbMap, pRbMap, sizeof(struct xran_prb_map));
+                        xran_init_PrbMap_from_cfg(&tmppRbMap, pRbMap, m_xranInit.mtu);
+                        } /* if(pRbMap) */
+                    else {
+                        std::cout << "DL pRbMap ==NULL" << std::endl;
+                        }
+
+                if(get_rucategory() == XRAN_CATEGORY_B){
+                    pRbMap = (struct xran_prb_map *)psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
+                    if(pRbMap) {
+                        pRbMap->dir                     = XRAN_DIR_DL;
+                        pRbMap->xran_port               = 0;
+                        pRbMap->band_id                 = 0;
+                        pRbMap->cc_id                   = cc_id;
+                        pRbMap->ru_port_id              = ant_id;
+                        pRbMap->tti_id                  = tti;
+                        pRbMap->start_sym_id            = 0;
+
+                        pRbMap->nPrbElm                 = 1;
+                        pRbMap->prbMap[0].nRBStart      = 0;
+                        pRbMap->prbMap[0].nRBSize       = get_num_dlrbs();
+                        pRbMap->prbMap[0].nStartSymb    = 0;
+                        pRbMap->prbMap[0].numSymb       = 14;
+                        pRbMap->prbMap[0].nBeamIndex    = 0;
+                        pRbMap->prbMap[0].compMethod    = XRAN_COMPMETHOD_NONE;
+                        uint32_t idxElm;
+                        int iPrb;
+                        char *dl_bfw_pos = ((char*)p_tx_dl_bfw_buffer[flowId]) + tx_dl_bfw_buffer_position[flowId];
+                        struct xran_prb_elm* p_prbMap = NULL;
+                        int num_antelm;
+
+                        pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_WEIGHT;
+                        pRbMap->prbMap[0].bf_weight_update  = 1;
+
+                        num_antelm = get_num_antelmtrx();
+#if 1
+                        /* populate beam weights to C-plane for each elm */
+                        // pRbMap->bf_weight.nAntElmTRx = num_antelm;
+                        for(idxElm = 0;  idxElm < pRbMap->nPrbElm; idxElm++){
+                            p_prbMap = &pRbMap->prbMap[idxElm];
+                            for (iPrb = p_prbMap->nRBStart; iPrb < (p_prbMap->nRBStart + p_prbMap->nRBSize); iPrb++) {
+                                /* copy BF W IQs for 1 PRB of */
+                                p_prbMap->bf_weight.nAntElmTRx = num_antelm;
+                                // memcpy(&p_prbMap->bf_weight.p_ext_section[iPrb][0], (dl_bfw_pos + (iPrb * num_antelm)*4), num_antelm*4);
+                                }
+                            }
+#endif
+                        } /* if(pRbMap) */
+                    else {
+                        std::cout << "Cp DL pRbMap ==NULL" << std::endl;
+                        }
+
+                    pRbMap = (struct xran_prb_map *)psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
+                    if(pRbMap) {
+                        pRbMap->dir                     = XRAN_DIR_DL;
+                        pRbMap->xran_port               = 0;
+                        pRbMap->band_id                 = 0;
+                        pRbMap->cc_id                   = cc_id;
+                        pRbMap->ru_port_id              = ant_id;
+                        pRbMap->tti_id                  = tti;
+                        pRbMap->start_sym_id            = 0;
+
+                        pRbMap->nPrbElm                 = 1;
+                        pRbMap->prbMap[0].nRBStart      = 0;
+                        pRbMap->prbMap[0].nRBSize       = get_num_dlrbs();
+                        pRbMap->prbMap[0].nStartSymb    = 0;
+                        pRbMap->prbMap[0].numSymb       = 14;
+                        pRbMap->prbMap[0].nBeamIndex    = 0;
+                        pRbMap->prbMap[0].compMethod    = XRAN_COMPMETHOD_NONE;
+                        int idxElm;
+                        int iPrb;
+                        char *dl_bfw_pos = ((char*)p_tx_dl_bfw_buffer[flowId]) + tx_dl_bfw_buffer_position[flowId];
+                        struct xran_prb_elm* p_prbMap = NULL;
+                        // int num_antelm;
+
+                        pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_WEIGHT;
+                        pRbMap->prbMap[0].bf_weight_update  = 1;
+
+                        // num_antelm = get_num_antelmtrx();
+#if 0
+                        /* populate beam weights to C-plane for each elm */
+                        pRbMap->bf_weight.nAntElmTRx = num_antelm;
+                        for(idxElm = 0;  idxElm < pRbMap->nPrbElm; idxElm++){
+                            p_prbMap = &pRbMap->prbMap[idxElm];
+                            for (iPrb = p_prbMap->nRBStart; iPrb < (p_prbMap->nRBStart + p_prbMap->nRBSize); iPrb++) {
+                                /* copy BF W IQs for 1 PRB of */
+                                memcpy(&pRbMap->bf_weight.weight[iPrb][0], (dl_bfw_pos + (iPrb * num_antelm)*4), num_antelm*4);
+                                }
+                            }
+#endif
+                        } /* if(pRbMap) */
+                    else {
+                        std::cout << "Cp UL pRbMap ==NULL" << std::endl;
+                        }
+                }
+
+
+                    /* C-plane UL */
+                    pRbMap = (struct xran_prb_map *)psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[tti][cc_id][ant_id].sBufferList.pBuffers->pData;
+                    if(pRbMap) {
+                        pRbMap->dir                     = XRAN_DIR_UL;
+                        pRbMap->xran_port               = 0;
+                        pRbMap->band_id                 = 0;
+                        pRbMap->cc_id                   = cc_id;
+                        pRbMap->ru_port_id              = ant_id;
+                        pRbMap->tti_id                  = tti;
+                        pRbMap->start_sym_id            = 0;
+
+                        pRbMap->nPrbElm                 = 1;
+                        pRbMap->prbMap[0].nRBStart      = 0;
+                        pRbMap->prbMap[0].nRBSize       = get_num_ulrbs();
+                        pRbMap->prbMap[0].nStartSymb    = 0;
+                        pRbMap->prbMap[0].numSymb       = 14;
+                        pRbMap->prbMap[0].nBeamIndex    = 0;
+                        pRbMap->prbMap[0].compMethod    = XRAN_COMPMETHOD_NONE;
+
+                        if(get_rucategory() == XRAN_CATEGORY_A) {
+                            pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_ID_BASED;
+                            pRbMap->prbMap[0].bf_weight_update  = 0;
+                            //pRbMap->prbMap[0].bf_attribute.weight[];
+                            //pRbMap->prbMap[0].bf_precoding.weight[];
+                            }
+                        else if(get_rucategory() == XRAN_CATEGORY_B) {
+                            int idxElm;
+                            int iPrb;
+                            char *ul_bfw_pos =  ((char*)p_tx_ul_bfw_buffer[flowId]) + tx_ul_bfw_buffer_position[flowId];
+                            struct xran_prb_elm* p_prbMap = NULL;
+                            // int num_antelm;
+
+                            pRbMap->prbMap[0].BeamFormingType   = XRAN_BEAM_WEIGHT;
+                            pRbMap->prbMap[0].bf_weight_update  = 1;
+
+                            // num_antelm = get_num_antelmtrx();
+#if 0
+                            /* populate beam weights to C-plane for each elm */
+                            pRbMap->bf_weight.nAntElmTRx = num_antelm;
+                            for (idxElm = 0;  idxElm < pRbMap->nPrbElm; idxElm++){
+                                p_prbMap = &pRbMap->prbMap[idxElm];
+                                for (iPrb = p_prbMap->nRBStart; iPrb < (p_prbMap->nRBStart + p_prbMap->nRBSize); iPrb++){
+                                    /* copy BF W IQs for 1 PRB of */
+                                    memcpy(&pRbMap->bf_weight.weight[iPrb][0], (ul_bfw_pos + (iPrb*num_antelm)*4), num_antelm*4);
+                                    }
+                                }
+#endif
+                            } /* else if(get_rucategory() == XRAN_CATEGORY_B) */
+                        memcpy(&tmppRbMap, pRbMap, sizeof(struct xran_prb_map));
+                        xran_init_PrbMap_from_cfg(&tmppRbMap, pRbMap, m_xranInit.mtu);
+                        } /* if(pRbMap) */
+                    else {
+                        std::cout << "UL: pRbMap ==NULL" << std::endl;
+                        }
+                    }
+                }
+            }
+
+        return (0);
+    }
+
+    void Cleanup()
+    {
+        int i;
+
+        if(get_rucategory() == XRAN_CATEGORY_B) {
+            for(i = 0; i < MAX_ANT_CARRIER_SUPPORTED && i < (get_num_cc() * get_num_eaxc()); i++) {
+                if(p_tx_dl_bfw_buffer[i]) {
+                    free(p_tx_dl_bfw_buffer[i]);
+                    p_tx_dl_bfw_buffer[i] = NULL;
+                    }
+
+                if(p_tx_ul_bfw_buffer[i]) {
+                    free(p_tx_ul_bfw_buffer[i]);
+                    p_tx_ul_bfw_buffer[i] = NULL;
+                    }
+                }
+            }
+
+        return;
+    }
+
+
+    void Open(uint32_t o_xu_id, xran_ethdi_mbuf_send_fn send_cp, xran_ethdi_mbuf_send_fn send_up,
+            void *fh_rx_callback, void *fh_bfw_callback, void *fh_rx_prach_callback, void *fh_srs_callback)
+    {
+        struct xran_fh_config *pXranConf;
+        int32_t nSectorNum;
+        int i, j, k, z;
+
+        struct bbu_xran_io_if *psBbuIo = (struct bbu_xran_io_if*)&m_gsXranIoIf;
+        struct xran_io_shared_ctrl *psIoCtrl =  (struct xran_io_shared_ctrl *)&psBbuIo->ioCtrl[o_xu_id];
+
+        uint32_t xran_max_antenna_nr = RTE_MAX(get_num_eaxc(), get_num_eaxc_ul());
+        uint32_t xran_max_ant_array_elm_nr = RTE_MAX(get_num_antelmtrx(), xran_max_antenna_nr);
+
+        struct xran_buffer_list *pFthTxBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthTxPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxRachBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxRachBufferDecomp[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxSrsBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthRxSrsPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_N_FE_BUF_LEN];
+
+        struct xran_buffer_list *pFthRxCpPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_N_FE_BUF_LEN];
+        struct xran_buffer_list *pFthTxCpPrbMapBuffer[XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_N_FE_BUF_LEN];
+
+#if 0
+        xran_reg_physide_cb(xranHandle, physide_dl_tti_call_back, NULL, 10, XRAN_CB_TTI);
+        xran_reg_physide_cb(xranHandle, physide_ul_half_slot_call_back, NULL, 10, XRAN_CB_HALF_SLOT_RX);
+        xran_reg_physide_cb(xranHandle, physide_ul_full_slot_call_back, NULL, 10, XRAN_CB_FULL_SLOT_RX);
+#endif
+        nSectorNum = get_num_cc();
+
+        for(i=0; i<nSectorNum; i++) {
+            for(j=0; j<XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < /*xran_max_antenna_nr*/XRAN_MAX_ANTENNA_NR; z++) {
+                    pFthTxBuffer[i][z][j]       = NULL;
+                    pFthTxPrbMapBuffer[i][z][j] = NULL;
+                    pFthRxBuffer[i][z][j]       = NULL;
+                    pFthRxPrbMapBuffer[i][z][j] = NULL;
+                    pFthRxRachBuffer[i][z][j]   = NULL;
+                    pFthRxRachBufferDecomp[i][z][j]   = NULL;
+                    pFthRxCpPrbMapBuffer[i][z][j]     = NULL;
+                    pFthTxCpPrbMapBuffer[i][z][j]     = NULL;
+                }
+                for(z = 0; z < /*xran_max_ant_array_elm_nr*/XRAN_MAX_ANT_ARRAY_ELM_NR; z++) {
+                    pFthRxSrsBuffer[i][z][j] = NULL;
+                    pFthRxSrsPrbMapBuffer[i][z][j] = NULL;
+                }
+            }
+        }
+
+        for(i=0; i<nSectorNum; i++) {
+            for(j=0; j<XRAN_N_FE_BUF_LEN; j++) {
+                for(z = 0; z < /*xran_max_antenna_nr*/XRAN_MAX_ANTENNA_NR; z++) {
+                    pFthTxBuffer[i][z][j]       = &(psIoCtrl->sFrontHaulTxBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthTxPrbMapBuffer[i][z][j] = &(psIoCtrl->sFrontHaulTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthRxBuffer[i][z][j]       = &(psIoCtrl->sFrontHaulRxBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthRxPrbMapBuffer[i][z][j] = &(psIoCtrl->sFrontHaulRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthRxRachBuffer[i][z][j]   = &(psIoCtrl->sFHPrachRxBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthRxRachBufferDecomp[i][z][j]   = &(psIoCtrl->sFHPrachRxBbuIoBufCtrlDecomp[j][i][z].sBufferList);                    
+                    pFthRxCpPrbMapBuffer[i][z][j]     = &(psIoCtrl->sFHCpRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthTxCpPrbMapBuffer[i][z][j]     = &(psIoCtrl->sFHCpTxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
+                    }
+                for(z = 0; z < XRAN_MAX_ANT_ARRAY_ELM_NR /*xran_max_ant_array_elm_nr && xran_max_ant_array_elm_nr*/; z++) {
+                    pFthRxSrsBuffer[i][z][j] = &(psIoCtrl->sFHSrsRxBbuIoBufCtrl[j][i][z].sBufferList);
+                    pFthRxSrsPrbMapBuffer[i][z][j] = &(psIoCtrl->sFHSrsRxPrbMapBbuIoBufCtrl[j][i][z].sBufferList);
+            }
+                }
+            }
+
+        if(psBbuIo->nInstanceHandle[o_xu_id] != NULL) {
+            for(i = 0; i<nSectorNum; i++) {
+                xran_5g_fronthault_config(psBbuIo->nInstanceHandle[o_xu_id][i],
+                        pFthTxBuffer[i], pFthTxPrbMapBuffer[i],
+                        pFthRxBuffer[i], pFthRxPrbMapBuffer[i],
+                        (void (*)(void *, xran_status_t))fh_rx_callback, &pFthRxBuffer[i][0]);
+
+                xran_5g_bfw_config(psBbuIo->nInstanceHandle[o_xu_id][i],
+                        pFthRxCpPrbMapBuffer[i],
+                        pFthTxCpPrbMapBuffer[i],
+                        (void (*)(void *, xran_status_t))fh_bfw_callback, &pFthRxCpPrbMapBuffer[i][0]);
+
+                xran_5g_prach_req(psBbuIo->nInstanceHandle[o_xu_id][i], pFthRxRachBuffer[i],pFthRxRachBufferDecomp[i],
+                        (void (*)(void *, xran_status_t))fh_rx_prach_callback, &pFthRxRachBuffer[i]);
+                }
+
+            /* add SRS callback here */
+            for (i = 0; i<nSectorNum && xran_max_ant_array_elm_nr; i++) {
+                xran_5g_srs_req(psBbuIo->nInstanceHandle[o_xu_id][i], pFthRxSrsBuffer[i], pFthRxSrsPrbMapBuffer[i],
+                    (void (*)(void *, xran_status_t))fh_srs_callback, pFthRxSrsBuffer[i]);
+                }
+
+            }
+
+        xran_register_cb_mbuf2ring(send_cp, send_up);
+        xran_open(m_xranhandle, &m_xranConf);
+    }
+
+    void Close()
+    {
+        if(m_xranhandle)
+            xran_close(m_xranhandle);
+    }
+
+    int Start()
+    {
+        if(m_xranhandle)
+            return(xran_start(m_xranhandle));
+        else
+            return (-1);
+    }
+
+    int Stop()
+    {
+        if(m_xranhandle)
+            return(xran_stop(m_xranhandle));
+        else
+            return (-1);
+    }
+
+    /* emulation of timer */
+    void update_tti()
+    {
+        tti_ota_cb(nullptr, get_timer_ctx());
+    }
+
+    void update_symbol_index()
+    {
+        int i;
+        for (i=0; i<XRAN_PORTS_NUM; i++)
+            xran_lib_ota_sym_idx[i]++;
+        if((xran_lib_ota_sym_idx[0] % N_SYM_PER_SLOT) == 0) {
+            update_tti();
+            }
+        for (i=0; i<XRAN_PORTS_NUM; i++)
+        {
+            xran_lib_ota_sym[i]++;
+            if(xran_lib_ota_sym[i] >= N_SYM_PER_SLOT)
+                xran_lib_ota_sym[i] = 0;
+        }
+
+    }
+
+    int apply_cpenable(bool flag)
+    {
+        struct xran_device_ctx *pCtx = xran_dev_get_ctx();
+
+        if(is_running())
+            return (-1);
+
+        if(pCtx == nullptr)
+            return (-1);
+
+        if(flag == true) {
+            m_xranConf.enableCP = 1;
+            pCtx->enableCP = 1;
+            }
+        else {
+            m_xranConf.enableCP = 0;
+            pCtx->enableCP = 0;
+            }
+
+        return (0);
+    }
+
+
+    int get_slot_config(const std::string &cfgname, struct xran_frame_config *pCfg)
+    {
+        int numcfg, i, j;
+        std::vector<int> slotcfg;
+
+        numcfg = get_globalcfg<int>(cfgname, "period");
+        pCfg->nTddPeriod = numcfg;
+        for(i=0; i < numcfg; i++) {
+            std::stringstream slotcfgname;
+
+            slotcfgname << "slot" << i;
+            std::vector<int> slotcfg = get_globalcfg_array<int>(cfgname, slotcfgname.str());
+
+            for(j=0; j < (int)slotcfg.size(); j++)
+                pCfg->sSlotConfig[i].nSymbolType[j] = slotcfg[j];
+            pCfg->sSlotConfig[i].reserved[0] = 0; pCfg->sSlotConfig[i].reserved[1] = 0;
+            }
+
+        return (numcfg);
+    }
+
+    int get_num_rbs(uint32_t nNumerology, uint32_t nBandwidth, bool nSub6)
+    {
+        if(nNumerology > 3)
+            return (-1);
+
+        if(nSub6) {
+            if (nNumerology < 3) {
+                /* F1 Tables 38.101-1 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB */
+                switch(nBandwidth) {
+                    case PHY_BW_5MHZ:   return(nNumRbsPerSymF1[nNumerology][0]);
+                    case PHY_BW_10MHZ:  return(nNumRbsPerSymF1[nNumerology][1]);
+                    case PHY_BW_15MHZ:  return(nNumRbsPerSymF1[nNumerology][2]);
+                    case PHY_BW_20MHZ:  return(nNumRbsPerSymF1[nNumerology][3]);
+                    case PHY_BW_25MHZ:  return(nNumRbsPerSymF1[nNumerology][4]);
+                    case PHY_BW_30MHZ:  return(nNumRbsPerSymF1[nNumerology][5]);
+                    case PHY_BW_40MHZ:  return(nNumRbsPerSymF1[nNumerology][6]);
+                    case PHY_BW_50MHZ:  return(nNumRbsPerSymF1[nNumerology][7]);
+                    case PHY_BW_60MHZ:  return(nNumRbsPerSymF1[nNumerology][8]);
+                    case PHY_BW_70MHZ:  return(nNumRbsPerSymF1[nNumerology][9]);
+                    case PHY_BW_80MHZ:  return(nNumRbsPerSymF1[nNumerology][10]);
+                    case PHY_BW_90MHZ:  return(nNumRbsPerSymF1[nNumerology][11]);
+                    case PHY_BW_100MHZ: return(nNumRbsPerSymF1[nNumerology][12]);
+                }
+            }
+        }
+        else { /* if(nSub6) */
+            if((nNumerology >= 2) && (nNumerology <= 3)) {
+                nNumerology -= 2;
+                /* F2 Tables 38.101-2 Table 5.3.2-1. Maximum transmission bandwidth configuration NRB */
+                switch(nBandwidth) {
+                    case PHY_BW_50MHZ:  return(nNumRbsPerSymF2[nNumerology][0]); break;
+                    case PHY_BW_100MHZ: return(nNumRbsPerSymF2[nNumerology][1]); break;
+                    case PHY_BW_200MHZ: return(nNumRbsPerSymF2[nNumerology][2]); break;
+                    case PHY_BW_400MHZ: return(nNumRbsPerSymF2[nNumerology][3]); break;
+                }
+            }
+        }
+
+        return(-1);
+    }
+
+    void *get_xranhandle()  { return(m_xranhandle); }
+    void *get_timer_ctx()   { return((void *)xran_dev_get_ctx()); }
+
+    int get_symbol_index()  { return (xran_lib_ota_sym[0]); }
+
+    bool is_running()       { return((xran_get_if_state() == XRAN_RUNNING)?true:false); }
+
+    enum xran_category get_rucategory()    { return(m_xranConf.ru_conf.xranCat); }
+
+    int get_numerology()    { return(m_xranConf.frame_conf.nNumerology); }
+    int get_duplextype()    { return(m_xranConf.frame_conf.nFrameDuplexType); }
+    int get_num_cc()        { return(m_xranConf.nCC); }
+    int get_num_eaxc()      { return(m_xranConf.neAxc); }
+    int get_num_eaxc_ul()   { return(m_xranConf.neAxcUl); }
+    int get_num_dlrbs()     { return(m_xranConf.nDLRBs); }
+    int get_num_ulrbs()     { return(m_xranConf.nULRBs); }
+    uint32_t get_num_antelmtrx() { return(m_xranConf.nAntElmTRx); }
+
+    bool is_cpenable()      { return(m_xranConf.enableCP); };
+    bool is_prachenable()   { return(m_xranConf.prachEnable); };
+    bool is_dynamicsection() { return(m_xranConf.DynamicSectionEna?true:false); }
+
+    void get_cfg_prach(struct xran_prach_config *pCfg)
+    {
+        if(pCfg)
+            memcpy(pCfg, &m_xranConf.prach_conf, sizeof(struct xran_prach_config));
+    }
+
+    void get_cfg_frame(struct xran_frame_config *pCfg)
+    {
+        if(pCfg)
+            memcpy(pCfg, &m_xranConf.frame_conf, sizeof(struct xran_frame_config));
+    }
+
+    void get_cfg_ru(struct xran_ru_config *pCfg)
+    {
+        if(pCfg)
+            memcpy(pCfg, &m_xranConf.ru_conf, sizeof(struct xran_ru_config));
+    }
+
+    void get_cfg_fh(struct xran_fh_config *pCfg)
+    {
+        if(pCfg)
+            memcpy(pCfg, &m_xranConf, sizeof(struct xran_fh_config));
+    }
 
-  void get_cfg_fh(struct xran_fh_config *pCfg);
 };
 
+
 /* external declaration for the instance */
 extern xranLibWraper *xranlib;
 
-#endif // XRAN_LIB_WRAP_HPP
+
+#endif //XRAN_LIB_WRAP_HPP
diff --git a/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fh.band78.fr1.273PRB.conf b/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fh.band78.fr1.273PRB.conf
index 90f60f10d2..960eb76868 100644
--- a/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fh.band78.fr1.273PRB.conf
+++ b/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fh.band78.fr1.273PRB.conf
@@ -180,7 +180,7 @@ gNBs =
 
 
     ////////// AMF parameters:
-    amf_ip_address      = ( { ipv4       = "10.10.10.200";
+    amf_ip_address      = ( { ipv4       = "192.168.70.132";
                               ipv6       = "192:168:30::17";
                               active     = "yes";
                               preference = "ipv4";
@@ -189,10 +189,10 @@ gNBs =
 
     NETWORK_INTERFACES :
     {
-        GNB_INTERFACE_NAME_FOR_NG_AMF            = "ens2f2";
-        GNB_IPV4_ADDRESS_FOR_NG_AMF              = "10.10.10.199/24";
-        GNB_INTERFACE_NAME_FOR_NGU               = "ens2f2";
-        GNB_IPV4_ADDRESS_FOR_NGU                 = "10.10.10.199/24";
+        GNB_INTERFACE_NAME_FOR_NG_AMF            = "demo-oai";
+        GNB_IPV4_ADDRESS_FOR_NG_AMF              = "192.168.70.129/26";
+        GNB_INTERFACE_NAME_FOR_NGU               = "demo-oai";
+        GNB_IPV4_ADDRESS_FOR_NGU                 = "192.168.70.129/26";
         GNB_PORT_FOR_S1U                         = 2152; # Spec 2152
     };
   }
diff --git a/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fhi.json b/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fhi.json
index 86366160af..bc293151b6 100644
--- a/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fhi.json
+++ b/targets/PROJECTS/GENERIC-NR-5GC/CONF/oran.fhi.json
@@ -1,20 +1,19 @@
 {
     "GLOBAL": {
         "io_cfg": {
-            "dpdk_dev_up":          "0000:8a:0a.0",
-            "dpdk_dev_cp":          "0000:8a:0a.1",
+            "dpdk_dev_up":          "0000:31:01.0",
+            "dpdk_dev_cp":          "0000:31:01.1",
             "bbdev_mode":           "none",
-            "system_core":          0,
-            "core":                 1,
-            "pkt_proc_core":        2,
-            "timing_core":          1,
-            "pkt_aux_core":         1,
-            "txq_id":         0,
-            "rxq_id":         0,
+            "system_core":          1,
+            "core":                 2,
+            "pkt_proc_core":        24,
+            "timing_core":          5,
+            "pkt_aux_core":         0,
             "dpdkBasebandFecMode":  0,
             "dpdkBasebandDevice":   "",
-            "mtu":                  8870,
-            "o_du_macaddr":         "00:11:22:33:44:66",
+            "dpdkMemorySize":       8192,
+            "mtu":                  9600,
+            "o_du_macaddr":         "00:11:22:33:00:00",
             "o_ru_macaddr":         "98:ae:71:01:64:D8",
             "cp_vlan_tag":          1,
             "up_vlan_tag":          2
@@ -38,7 +37,7 @@
         "ru_cfg": {
             "category":         "A",
             "duplex":           "TDD",
-            "slot_config":      "slotcfg_0",
+            "slot_config":      "slotcfg_2",
             "sub6":             true,
             "mu":               1,
             "num_cc":           1,
@@ -84,8 +83,22 @@
             "slot1":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
             "slot2":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
             "slot3":    [ 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
-            }
-        },
+            },
+            "slotcfg_2": {
+              "desc":     "DDDSUUDDDD_644",
+              "period":   10,
+              "slot0":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot1":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot2":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot3":    [ 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1 ],
+              "slot4":    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
+              "slot5":    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
+              "slot6":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot7":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot8":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
+              "slot9":    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
+              },
+          },
 
     "u_plane_functional": [
       {
@@ -997,7 +1010,7 @@
       "name": "xran_lib_api",
       "parameters": {
         "id": 0,
-        "dpdk_dev": [ "0000:d8:02.0", "0000:d8:02.1" ],
+        "dpdk_dev": [ "0000:31:01.0", "0000:31:01.1" ],
         "bbdev_dev": "none",
         "bbdev_mode": 0,
         "core": 5,
